# 类与对象1

## 类与对象

1. 类和对象：下面例子中，类是Cat，对象是myCat

   ```java
   public class Program{
     public static void main(String[] args){
       Cat myCat = new Cat();
     }
   }
   
   class Cat{
     // 成员变量 / 属性
     // 成员变量可以是基本数据类型，也可以是引用类型比如字符串和数组
     String name;
     int age
     String color;
     
     // 方法
     public Miao(){
       System.out.println("Miao");
     }
   }
   ```

2. 类和对象在内存中的形式

   ```json
   {
       "栈": "0x0011",
       "堆": 
     	{
           "0x0011": ["0x0022", 3, "0x0033"]
       },
       "方法区": 
     	{
           "常量池": 
         	{
               "0x0022": "Jack",
               "0x0033": "Yellow"
           }
       }
   }
   ```

3. 访问修饰符：public、protected、默认、private

4. 属性

   1. 属性的定义：`访问修饰符 属性类型 属性名;`
   2. 属性可以是基本数据类型，也可以是引用类型比如字符串和数组
   3. 属性如果不赋值，有默认值，规则和数组一致

## 成员方法

1. 案例：输出“我是好人”

   ```java
   public class Program{
     public static void main(String[] args){
       Person me = new Person();
       me.say(); // 调用方法
     }
   }
   
   class Person{
     // 方法
     public void say(){
       System.out.println("我是好人");
     }
   }
   ```

2. 传参

   ```java
   public class Program{
     public static void main(String[] args){
       Calculater cal = new Calculater();
   		System.out.println(cal.sum(1,2)); // 3
     }
   }
   
   class Calculater{
   	public int sum(int x,int y){
       return x+y;
     }
   }
   ```

3. 方法的调用机制

   1. 当程序执行到方法时，就会开辟一个独立的空间（栈空间）
   2. 当方法执行到return（执行完毕），就会返回到调用方法的地方

   ```json
   {	
   	"栈": 
     {
       "main栈":
       {
         0:"Calculater cal = new Calculater();",
         1:"System.out.println(cal.sum(1,2));" //<---执行到这里
       },
       "sum栈": //<---return后sum栈自动销毁
       {
         0:"return x+y;"
       }
     },
     "堆": 
     {
       "0x0011": "cal对象"
     },
     "方法区": 
     {}
   }
   ```

4. 成员方法定义

   ```java
   public 返回数据类型 方法名(形参列表..){
     语句;
     return 返回值;
   }
   ```

5. 返回多个返回值，建议使用数组。return类型需要与声明的一直或兼容：比如`public double getMoney(int i){..}`然后里边`int a = 1; return a; `是可以的，这里int会自动转化成double。

6. 方法名：建议使用小驼峰命名法

7. 形参列表

   1. 一个方法可以有多个参数也可以没有参数
   2. 参数类型可以为基本类型和引用类型
   3. 调用带参数的方法，要传入相同或兼容的类型的参数

8. 方法中不能定义方法

9. 方法调用

   1. 同一个类中：直接调用

      ```java
      class Cat{
      	public void miao(){
      		System.out.println("Miao~");
      	}
        public void doubleMiao(){
          miao();//同一个类中：直接调用
          miao();
        }
      }
      ```

   2. 跨类中的方法（A类调用B类）：需要通过对象名调用

      ```java
      class Cat{
      	public void miao(){
      		System.out.println("Miao~");
      	}
      }
      class Dog{
        public void biteCat(){
          System.out.println("Woof!");
          Cat cat = new Cat();
          cat.miao(); //跨类中的方法
        }
      }
      ```

## 成员方法传参机制

方法会改变调用位置的引用类型的参数，不会改变基础类型的参数

```java
public class Program{
  public static void main(String[] args){
    int x = 1;
    String y = "Hello";
    Cat z1 = new Cat(2);
    Cat z2 = new Cat(2);
    Tester tester = new Tester();
    tester.change(x,y,z1,z2);
    System.out.println("x="+x); //1
    System.out.println("y="+y); //Hello
    System.out.println("z1.age="+z1.age); //3
    System.out.println("z2.age="+z2.age); //2
  }
}

class Tester{
  public void change(int x,String y,Cat z1, Cat z2){
    x = 10;
    y = "World";
    z1.age = 3;
    z2 = null;
  }
}

class Cat{
  int age;
  public Cat(int age){
    this.age = age;
  }
}
```

## Overload

* 方法重载：同一个类中，多个同名方法存在，单要求形参不同

* 小案例

  ```java
  public class Program{
    public static void main(String[] args){
      T t = new T();
      // 调用了 public int plus(int a, int b)
      System.out.println(t.plus(1,2)); // 3
      // 调用了 public double plus(double a, double b)
      System.out.println(t.plus(1.1,2.2)); // 3.3
      // 调用了 public double plus(double a, double b)
      // 1隐形转换成了1.0
      System.out.println(t.plus(1,2.0)); // 3.0
    }
  }
  
  class T{
    public int plus(int a, int b){
      return a+b;
    }
    public double plus(double a, double b){
      return a+b;
    }
  }
  ```

* 要求：方法名必须相同，参数列表必须不同，对返回类型无要求

## 可变参数

* 可变参数：参数个数不确定，`function(int... a)`，上例中的a可以方程数组

* 小案例

  ```java
  public class Program{
    public static void main(String[] args){
      T t = new T();
      System.out.println(t.plus(1,2,3,4)); // 10.0
    }
  }
  
  class T{
    public double plus(double... num){
      double sum = 0;
      for(int i=0;i<num.length;i++)
        sum+=num[i];
      return sum;
    }
    public double plus2(String str, double... num){
      System.out.print(str);
      return plus(num);
    }
  }
  ```

* 细节

  ```java
  // 可变参数的是惨可以为0或任意多个
  System.out.println(t.plus(1,2,3,4)); // 0.0
  // 可变参数的实惨可以为数组 - 可变参数本质就是数组
  System.out.println(t.plus(new double[]{1,2,3,4})); //10.0
  // 可变参数可以和普通参数放在一起，可变参数要在最后
  System.out.println(t.plus2("结果为:",new double[]{1,2}));//结果为:3.0
  // 形参列表只能有一个可变参数
  ```

## 作用域

|        |   全局变量    |   局部变量   |
| :----: | :-----------: | :----------: |
|  别称  | 成员变量/属性 |      -       |
|  位置  |   class里边   |   函数里边   |
| 默认值 |      有       |      无      |
| 修饰符 | 可以加修饰符  | 不能加修饰符 |

## 构造器

* 构造器案例

  ```java
  public class program{
    public static void main(String args[]){
      // 构造器可以进行方法重载
      // 构造器不能有返回值
      Person p1 = new Person();
      Person p2 = new Person(18,"Carl");
      Person p3 = new Person(22);
      System.out.println(p1.age);
      System.out.println(p2.age);
      System.out.println(p3.age);
    }
  }
  class Person{
    int age;
    String name;
    public Person(){
      age = 1;
    }
    public Person(int _age, String _name){
      age = _age;
      name = _name;
    }
    
    public Person(int _age){
      age = _age;
    }
  }
  ```

* 不写构造器的时候，一个类在编译的时候也会有构造器！

  ```java
  public Person{}
  
  // 但是编译的时候会生成默认的构造器：
  public Person{
    Person(){} // <- 默认构造器
  }
  
  // 但是当用户写了构造器之后，默认构造器就没了，就不能再直接new Person();了
  ```

* 对象创建流程的分析（面试题）

  ```java
  class Person{
    int age = 90;
    String name;
    Person(String n, int a){
      name = n;
      age = a;
    }
  }
  ```

  1. 下面是执行`Person p = new Person("小倩",20);`的流程
  2. 在「方法区」加载「类信息(Person类)」
  3. 在「堆」开辟空间，比如「0x1122」，里边有age和name两个字段，
  4. age默认是0，name默认是null，这一步是「隐式初始化」
  5. 进行「显式初始化」，age赋值成90
  6. 运行「构造函数」，age赋值成20，name赋值成0x1133，0x1133是常量池中保存name的位置的地址，该地址保存名字“小倩”
  7. 最后把0x1122赋值到「栈」里边的p变量，p是对象的引用

## this

* 引入this

  ```java
  public Dog{
    String name;
    int age;
    /*
    public Dog(String _name, int _age){
      name = _name;
      age = _age;
    }*/
    // 有没有另一种方法，让代码更好读
    public Dog(String name, int age){
      this.name = name;
      this.age = age;
    }
  }
  ```

* this本质：其实this和name、age一样，都是成员变量，不过this被隐藏起来了，this存放的是对象自己的地址！

* 构造器与this

  ```java
  class T{
    String name;
    int age;
    public T(){
      this("Jack",80);// 必须放在第一句
      System.out.println("this来访问构造器");
    }
    public T(String name,int age){
      this.name = name;
      this.age = age;
    }
  }
  ```

## 猜拳游戏案例

```java
import java.util.Scanner;
import java.util.Random;
public class Program{
  public static void main(String args[]){
    Game game = new Game(3);
    game.run();
    game.showResult();
  }
}

class Game{
  int loop;
  int list[][];
  
  public Game(int loop){
    this.loop = loop;
    this.list = new int[loop][3];
  }
  
  private int _getComputer(){
    Random random = new Random();
    int result = random.nextInt(3);
    System.out.println("The computer choice is: "+result);
    return result;
  }
  
  private int _getPlayer(int i){
    System.out.println("===== " + (i+1) + " / " + loop + " ========");
    System.out.print("Please input choice(0~2): ");
    Scanner scanner = new Scanner(System.in);
    return scanner.nextInt();
  }
  
  public void run(){
    for(int i=0;i<loop;i++){
      list[i][0] = _getPlayer(i);
      list[i][1] = _getComputer();
      list[i][2] = list[i][1]==(list[i][0]+1)%3 ? 1:0;
    }
  }
  
  public void showResult(){
    int count = 0;
    for(int i=0;i<loop;i++)
      if(list[i][2]==1) count++;
    System.out.println("Win: "+count+"times!");
  }
}
/*
===== 1 / 3 ========
Please input choice(0~2): 2
The computer choice is: 1
===== 2 / 3 ========
Please input choice(0~2): 1
The computer choice is: 2
===== 3 / 3 ========
Please input choice(0~2): 0
The computer choice is: 0
Win: 1times!
*/
```

