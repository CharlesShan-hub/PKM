# 运算方法和运算电路
2022.08.20

[TOC]

## 基本运算部件

> Overview：
>
> 注意本节不是重点！
>
> 1. 一位全加器：通过两个加数和上一位进位位，计算出本次的结果和进位位
> 2. 串行全加器：一个结果计算出来下一位再计算，速度慢
> 3. 并行全加器：利用公式把串行全加器结果算出来，这样一下就计算出来了
> 4. 带标志加法器：

### 一位全加器

和表达式：$S_i= A_i\oplus B_i\oplus C_{i-1}$

进位表达式：$C_i = A_iB_i+(A_i\oplus B_i)C_{i-1}$

![img](resources/87b0d8f3b8411c30eb51930a6fdd315f.jpeg)

> 我的理解：
>
> 1. 和表达式：两个加数和上一位进位位，依次相加，这里的相加用的是异或
> 2. 进位表达式：两种情况，AB都是1，或，AB有一个是1一个是0同时上一位有进位

* 例题：加法器中每位的进位生成信号g为：$X_iY_i$，在设计多位加法器时，为了加快运算速度而采用了快速进位链，即对加法器的每位都生成两个信号：

  进位信号g：$X_iY_i$

  进位传递信号p：$X_i\oplus Y_i$

### 串行进位加法器

![img](resources/串行加法器.png)

缺点：时间慢

### 并行进位加法器

![img](resources/并行加法器.png)

$\begin{align}C_i &= A_iB_i+(A_i\oplus B_i)C_{i-1} \\&= G_i+P_iC_{i-1} = 自己两个1+自己一个1上一位有个进位\end{align}$

$C_1 = G_1+P_1C_0$

$C_2 = G_2+P_2C_1 = G_2 + P_2G_1 + P_2P_1C_0$

$C_3 = G_3+P_3C_2 = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1C_0$

$C_4 = G_4+P_4C_3 = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1 + P_4P_3P_2P_1C_0$

### 带标志加法器

![img](resources/带符号加法器.png)

溢出OF**（有符号数看OF）**：$C_i\oplus C_{i-1}$

符号SF：$F_{n-1}$

零标志ZF=1：当所有F=0

进位/借位CF**（无符号数看CF）**：$C_{out}\oplus C_{in}$，（加法CF=0，减法CF=1）

> 强烈推荐课程：
>
> * [聊聊运算状态标志位CF_OF_SF_ZF的底层实现](https://www.bilibili.com/video/BV1SU4y1f79y)
> * [Youtube：精讲18 第二章数据的表示和运算12 标志位的生成](https://www.youtube.com/watch?v=LbEWpHzZLEI&list=PLjAs5kw1NNs0x3sxuX4V9Lc48FMt6_A6a&index=18)

## 定点数的移位运算

### 算术移位

正数全加零，负数原码全加零，负数反码全加一，负数补码左移加0，右移加1

|      |       码制       | 填补代码 |
| :--: | :--------------: | :------: |
| 正数 | 原码、补码、反码 |    0     |
| 负数 |       原码       |    0     |
| 负数 |       补码       | 左移添0  |
| 负数 |       补码       | 右移添1  |
| 负数 |       反码       |    1     |

### 逻辑移位

溢出部分丢弃，左右都补零

### 循环移位

![img](resources/循环移位.png)



* 一个8位寄存器内的数值为 11001010，进位标志寄存器C为0，若将此 8位寄存器循环左移（**不带进位位**）1位则该8位寄存器和标志寄存器内的数值分别为（）。

  A. 1001 0100，1

  B. 1001 0101，0

  C. 1001 0101，1

  D. 1001 0100，0

  【答案】：C

  [CF, 11001010]

  [CF(1), 10010101]，注意，最左边的1也会同时移动到CF里边！

* 【2018统考真题】整数x的机器数为11011000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各是()。

  A.11101100、11101100

  B.01101100、11101100

  C.11101100、01101100

  D.01101100、01101100

  【答案】：B

## 定点数的加减运算

* $[x+y]_补 = [x]_补+[y]_补$

  $[x-y]_补 = [x]_补+[-y]_补$

* 符号位参与运算；最高位进位丢弃

* 例题：A=15，B=24，求$[A+B]_补$，$[A-B]_补$
  $$
  A = 15 &= [0,00001111]_补\\
  B = 24 &= [0,00011000]_补\\
  -B = -24 &= [1,11101000]_补\\
  A+B &= [0,00100111]_补\\
  A-B = -24 &= [1,11110111]_补\\
  $$
  
* 溢出判断：只有符号相同的数加减才会溢出

  ($A_s$：A的符号位，$B_s$：B的符号位，$S_s$：结果的符号位)

  * **一位符号位**：$V = A_sB_s\overline{S_s}+\overline{A_s}\cdot \overline{B_s}S_s$

    > 我的理解：
    >
    > ~~就是符号位001或110的时候，V的两项一定是000+111，最后得一。如果符号不同AsBs就会得到零让V得到零~~
    >
    > 1. 无论加减法都会加法器实现的，所以我们把加减法都考虑为加法
    > 2. 两个正数相加为负数，或两个负数相加为正数，说明溢出
    > 3. 正数与负数相加永远不会溢出
  
  * 双符号位
  
    * $$
      \begin{align}
      正数未溢出：S_{s1}S_{s2}&=00\\
      正数溢出：S_{s1}S_{s2}&=01\\
      负数溢出：S_{s1}S_{s2}&=10\\
      负数未溢出：S_{s1}S_{s2}&=11\\
      \end{align}
      $$
      
    * $$
      V = S_{si}\oplus S_{s2}
      $$
  
  * 例题：计算机字长为8位，CPU有一个8位加法器。无符号数x=69， y=38，如果在该加法器中计算x-y，则加法器的两个输入端信息和输入的地位进位信息分别为（ ）
    $$
    \begin{align}
    x = 69 = 64+4+1 &= 0100,0101\\
    y = 38 = 32+4+2 &= 0010,0110\\
    [x]_补 &= 0100,0101\\
    [-y]_补 &= 1101,1010
    \end{align}
    $$
    不管是补码减法，还是无符号数减法，都是用被减数加上减数的负数的补码来实现的。根据求补码公式，减数y的负数的补码为$[-y]_补=\overline{Y}+1$，因此，在加法器的Y'输入端用一个反向器实现，并用控制端Sub控制多路选择器是否将y的各位取反后，输入Y'端，同时将Sub作为低位进位送到加法器。

    当**Sub为1时，做减法，当Sub为0时，做加法**。69的二进制数为01000101；38的进制数为00100110，各位取反11011001。【这里注意，这道题重点是ALU内部电路实现，所以求$\overline{Y}$。至于$\overline{Y}+1$，是后边继续做的事了】。做减法时，低位进位为Sub,即为1。

    答案：0100 0101、1101 1001、1

  * 例题：某计算机中有一个8位加法器，带符号整数x和y的机器数用补码表示，[x]补=F5H, [y]补=7EH,如果在该加法器中计算x-y,则加法器的低位进位输入信息和运算后的溢出标志OF分别是()。

    A.1、1

    B.1、0

    C.0、1

    D.0、0
  
    $[x]_补 = F5H = 1111,0101$
  
    $[y]_补 = 7EH = 0111,1110$
  
    $[-y]_补 = 1000,0010$
  
    $[x]_补+[-y]_补 = 0111,1111$
  
    答案：A。加法器的低位进位输入信息就是sub，加法sub为0，减法sub为1.	

## 定点数的乘除运算

注意定点小数的除法也是用定点数来表示的，表示不了大于1的小数，所以定点小数除法中，被除数一定要小于除数！

|         算法          |  符号位  |      移动      |      |
| :-------------------: | :------: | :------------: | ---- |
|     原码一位乘法      | 单独运算 | 加一个右移一次 |      |
| 补码一位乘法（Booth） |          |                |      |
| 原码除法（恢复余数）  |          |                |      |
| 原码除法（加减交替）  |          |                |      |
| 补码除法（加减交替）  |          |                |      |

### 原码一位乘法

1. 符号单独运算
2. 例题：$[x]_原=1,1101, [y]_原=0,1011$

![img](resources/614166097554.png)

![img](resources/原码一位乘法.png)

符号位：$P_s = x_s\oplus y_s = 1$

结果：$[x\cdot y]_原 = 1,10001111$

> 推荐网课：
>
> * [Youtube: 精讲20 第二章数据的表示和运算14 原码的乘法运算](https://www.youtube.com/watch?v=iCoMSLIMiSA&list=PLjAs5kw1NNs0x3sxuX4V9Lc48FMt6_A6a&index=20)

### 补码一位乘法(Booth算法)

1. 符号参与运算

2. 运算规则

3. | $y_n$ | $y_{n-1}$(辅助位) |            操作             |
   | :---: | :---------------: | :-------------------------: |
   |   0   |         0         |       部分积右移一位        |
   |   0   |         1         | 部分积右移一位，加$[y]_补$  |
   |   1   |         0         | 部分积右移一位，加$[-y]_补$ |
   |   1   |         1         |       部分积右移一位        |

   例题

4. 原理（[链接](https://www.zhihu.com/question/37637775)）

   ![img](https://pic1.zhimg.com/v2-0120b5957c9ada3c71e6124cae3b92c7_r.jpg?source=1940ef5c)

5. [🌟原理讲解](怎么理解Booth算法? - SlieKongroo的回答 - 知乎 https://www.zhihu.com/question/37637775/answer/2375504267)

### 原码除法（恢复余数法）

1. 符号单独运算

2. 例题：$[x]_原=0,1101, [y]_原=0,1011$

   ![img](resources/原码恢复余数法.png)

   符号位：$P_s = x_s\oplus y_s = 0$

   结果：$[x\cdot y]_原 = 0,1101$

### 原码除法（加减交替法）

1. 符号单独运算

2. 加减次数：最后余数为正 n+1次，最后余数为负n+2次

3. 左移次数：n次，最后一轮不需要移动

4. 例题：$[x]_原=0,1101, [y]_原=0,1011$

   ![img](resources/原码除法不恢复余数法.png)

   符号位：$P_s = x_s\oplus y_s = 0$

   结果：$[x\cdot y]_原 = 0,1101$

### 补码除法（加减交替法）

1. 补码一位除法的特点是，符号位与数值位一起参加运算，商符自然形成。除法第一步根据被除数和除数的符号决定是做加法还是减法；上商的原则根据余数和除数的符号位共同决定，同号上商“1”，异号上商“0”；最后一步商恒置“1”。

   加减交替法的规则如下：

   ①符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。

   ②若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数。

   ③若余数与除数同号，则商上1，余数左移一位减去除数：若余数与除数异号，则商上0,余数左移一位加上除数。

   ④重复执行第③步操作n次。

   ⑤若对商的精度没有特殊要求，则一般采用“末位恒置1”法。

2. 例题：
   $$
   [x]_原=0,1101, [y]_原=1,1011\\
   [x]_补 = 0,1101\\
   [y]_补 = 1,0101\\
   [-y]_补 = 0,1011\\
   $$
   ![img](resources/补码加减交替法.png)

## C语言整数类型与类型转换

### 有符号数与无符号数

一般机器采用补码进行存储，下面是同样的内容通过short和unsigned short解释的结果：

| 变量            | 真值  | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| --------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| short x         | -4321 | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    |
| usigned short y | 61215 | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    |

### 不同字长的整数转换

多出的部分截断，少的位数补“零”

## 数据的存储与排列

### 大端字节序与小端字节序

`int i = 01234567H;`

![img](resources/字节序.png)

### “边界对齐”

假设32位计算机：

边界对齐：

![img](resources/对齐.png)

边界不对齐：

![img](resources/不对齐.png)

边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机通常采用边界对齐方式，因为对齐方式取指令时间相同，因此能适应指令流水线

例题：【2012统考真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定int和shot型长度分别为32位和16位，并且数据按边界对齐存储。某C语言程序段如下：

```c
strcut{
	int a;
  char b;
  short c;
}record;
record.a = 127;
```

* 若record 变量的首地址为 OxC008，地址 OxC008中的内容及record.c 的地址分别为（）
  A. 0×00, 0xC00D 
  B. 0x00, 0xC00E
  C. 0x11, 0xC00D
  D. 0x11. 0xC00E

  答案：注意，char类型是8bit。答案D

* 【2018统考真题】某32位计算机按字节编址，采用小端方式。若语句“iti=0;”对应指令的机器代码为“C745FC00000000”,则语句“int i = -64;”对应指令的机器代码是()。

  A.C7 45 FC C0 FF FF FF

  B.C7 45 FC 0C FF FF FF

  C.C7 45 FC FF FF FF C0

  D.C7 45 FC FF FF FF 0C

  答案：注意！小端字节序！C

* 【2018统考真题】减法指令“subR1,R2,R3”的功能为“(R1)-(R2)→R3”，该指令执行后将进行生成进位/借位标志CF和溢出标志OF,若(R1)=FFFF FFFF H, (R2) = FFFF FFF0 H, 则该减法指令执行后，CF与OF分别为()。

  A.CF=0,OF=0

  B.CF=1,OF=0

  C.CF=0,OF=1

  D.CF=1,OF=1

  答案：R1<R2 所以借位CF=1，
  $$
  \begin{align}
  [R_1]_补 &= FFFF,FFFF\\
  [R_2]_补 &= FFFF,FFF0\\
  [R_1 - R_2]_补&=FFFF,FFFF
  \end{align}
  $$