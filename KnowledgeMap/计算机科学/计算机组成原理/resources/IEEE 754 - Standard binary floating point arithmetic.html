
<!-- saved from url=(0041)http://www.softelectro.ru/ieee754_en.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	<title>IEEE 754 - Standard binary floating point arithmetic</title>
	
	
	<meta name="Author" content="Yashkardin Vladimir">
    	<meta name="Keywords" content="IEEE754 IEEE-754">
    	<meta name="Description" content="Descriptions of the IEEE 754 - Standard binary floating point arithmetic">

	</head><body style="FONT-SIZE: 12pt" text="black" bgcolor="#D3E3E3">
		<a target="_parent" href="http://www.softelectro.ru/teoriy_en.html" title="english"><img src="./IEEE 754 - Standard binary floating point arithmetic_files/england.gif" align="right" border="no"></a>
		<a target="_parent" href="http://www.softelectro.ru/teoriy.html" title="русский"><img src="./IEEE 754 - Standard binary floating point arithmetic_files/russia.gif" align="right" border="no"></a>
		
		<a target="_parent" href="http://www.softelectro.ru/index_en.html"> Home  </a>&nbsp;
		<a target="_parent" href="http://www.softelectro.ru/teoriy_en.html">Back </a>&nbsp;
		<br><br>
		<hr>
		<font style="font-size : 12pt ; font-style : italic; color : green">This page is translated from the original by using the Google translator.</font><br>
		<h1>IEEE 754 - Standard binary arithmetic float</h1>
		
		<p align="right">
		
		Author: Yashkardin Vladimir&nbsp; &nbsp; <br>
		www.softelectro.ru &nbsp; &nbsp;<br>
		2009-2011 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
		 info@softelectro.ru
		
		</p>
		
		
		
		<h3>§1. Title Standard.</h3>
		<p>This standard is designed association IEEE (Institute of Electrical and Electronics Engineers) and is used to represent real numbers (floating point) in binary code.
			The most used standard for floating point, used by many microprocessor and logic devices and software.
		</p>
		<ul>The full title of the Standard in association IEEE:
			<li><strong><i>IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985)</i></strong>
			
		</li></ul>
		<ul>Title of the Standard in International Electrotechnical Commission IEC:
			<li><strong><i>IEC 60559:1989, Binary floating-point arithmetic for microprocessor systems </i></strong>
			</li><li><strong><i>(IEC 559:1989 - the old designation of the standard)</i></strong>
		</li></ul>
		<p>In 2008, the association has released IEEE standard IEEE 754-2008, which included the standard IEEE 754-1985.
		
		</p><h3>§2.Brief description of the standard.</h3>
			The original edition of the standard:<br>
				<font style="font-style : italic; font-size : 10pt; color :  brown ">IEEE Standard for Binary Floating-Point Arithmetic <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Copyright 1985 by<br> The Institute of Electrical and Electronics Engineers, Inc <br>345 East 47th Street, New York, NY 10017, USA</font>
			<p>The standard contains 23 pages of text in 7 sections and one annex:
		  </p><dl>
			<dt>1.Scope
				</dt><dd>1.1 Implementation Objectives 
				</dd><dd>1.2 Inclusions 
				</dd><dd>1.3 Exclusions 
			</dd><dt>2.Definitions 
			</dt><dt>3.Formats 
				</dt><dd>3.1 Sets of Values 
				</dd><dd>3.2 Basic Formats 
				</dd><dd>3.3 Extended Formats 
				</dd><dd>3.4 Combinations of Formats 
			</dd><dt>4.Rounding (Округления)
				</dt><dd>4.1 Round to Nearest 
				</dd><dd>4.2 Directed Roundings
				</dd><dd>4.3 Rounding Precision 
			</dd><dt>5.Operations 
				</dt><dd>5.1 Arithmetic 
				</dd><dd>5.2 Square Root 
				</dd><dd>5.3 Floating-Point Format Conversions 
				</dd><dd>5.4 Conversion Between Floating-Point and Integer Formats 
				</dd><dd>5.5 Round Floating-Point Number to Integer Value
				</dd><dd>5.6 Binary &lt;-&gt; Decimal Conversion 
				</dd><dd>5.7 Comparison
			</dd><dt>6.Infinity, NaNs, and Signed Zero 
				</dt><dd>6.1 Infinity Arithmetic 
				</dd><dd>6.2 Operations with NaNs 
				</dd><dd>6.3 The Sign Bit 
			</dd><dt>7.Exceptions 
				</dt><dd>7.1 Invalid Operation 
				</dd><dd>7.2 Division by Zero 
				</dd><dd>7.3 Overflow 
				</dd><dd>7.4 Underflow 
				</dd><dd>7.5 Inexact 
			</dd><dt>8.Traps 
				</dt><dd>8.1 Trap Handler 
				</dd><dd>8.2 Precedence  
			</dd><dt>A.Recommended Functions and Predicates 
		  </dt></dl>
		<p></p>

		<p>&nbsp; &nbsp; &nbsp; &nbsp;Unfortunately, the IEEE has evolved from an international public engineering organization (which it was originally) a trade organization.<br>
			This organization owns the copyright to publish the standard IEEE754-1985. <br>
			 So if you want to read, with the original standard, you have to buy it for around 80 $. <br>
 			However, Russian law allows me to comment on teaching this standard. <br>
			 Therefore, the further I'll give an arbitrary presentation of standard and express their opinion about it for training purposes.


 
		</p>

		<ul> <strong>Standard IEEE 754-1985 will determine:</strong>
			<li> Be normalized as positive and negative floating point numbers 
			</li><li> How to represent the positive and negative denormalized floating point numbers 
			</li><li> How to represent the number of zero 
			</li><li> As a special value to represent infinity (Infiniti) 
			</li><li> How to represent a special value of "No number" (NaN or NaNs) 
			</li><li> Four modes of rounding
			
		</li></ul>
		<ul> <strong>IEEE 754-1985 defines four format for floating-point numbers:</strong>
			<li> Single-precision (single-precision) 32-bit
			</li><li> Double-precision (double-precision) 64-bit
			</li><li> With single extended precision (single-extended precision)&gt; = 43 bits (seldom used)
			</li><li> Double-extended precision (double-extended precision)&gt; = 79 bits (typically use 80 bit)
		</li></ul>
		
		
		<h3>§3. Basic concepts in the representation of floating point numbers.</h3>
		
		<h3>3.1 Submission of a normalized exponential form.</h3>
		<p>Take, for example, the decimal number 155.625<br>  
			Imagine the number in a normalized exponential form: 1,55625&#8729;10<sup>+2</sup>=1,55625&#8729;exp<sub>10</sub><sup>+2</sup> <br>
			
			Number  1,55625&#8729;exp<sub>10</sub><sup>+2</sup> consists of two parts: a mantissa M = 1.55625 and the exponent exp<sub>10</sub>=+2<br>
			If the mantissa is in the range 1 &lt;= M &lt;10, then the number considered to be normalized.<br>
			Exhibitor provided the basis of calculation (in this case 10) and order (in this case 2<br> 
			The order of the exponent can have a negative value, such as the number 0,0155625=1,55625&#8729;exp<sub>10</sub><sup>-2</sup>.
		</p>
		<h3>3.2 Submission of a denormalized exponential form.</h3>
		<p>Take, for example, the decimal number 155,625<br>  
			Imagine the number of denormalized exponential way: 0,155625&#8729;10<sup>+3</sup>=0,155625&#8729;exp<sub>10</sub><sup>+3</sup> <br>
			
			Number 0,155625&#8729;exp<sub>10</sub><sup>+3</sup> consists of two parts: a mantissa M = 0,155625  and exponent exp<sub>10</sub>=+3<br>
			If the mantissa is in the range 0,1 &lt;= M &lt;1, then the number is denormalized.<br>
			Exhibitor provided the basis of calculation (in this case 10) and order (in this case 3).<br> 
			The order of the exponent can have a negative value, such as the number 0,0155625=0,155625&#8729;exp<sub>10</sub><sup>-3</sup>.
		</p>


		<h3>3.3 Converting decimal to binary floating-point number.</h3>
		<p>Our problem is reduced to a decimal floating point numbers in binary floating-point number in exponential normalized form.
			To do this we expand the given number of binary digits:
		</p>
		<p>155,625 = 1&#8729;2<sup>7</sup> +0&#8729;2<sup>6</sup>+0&#8729;2<sup>5</sup>+1&#8729;2<sup>4</sup>+1&#8729;2<sup>3</sup>+0&#8729;2<sup>2</sup>+1&#8729;2<sup>1</sup>+1&#8729;2<sup>0</sup>+1&#8729;2<sup>-1</sup>+0&#8729;2<sup>-2</sup>+1&#8729;2<sup>-3</sup><br>
			155,625 =128   +   0    +  0   +  16 +  8    +  0   +  2     +   1   + 0.5  +  0    + 0.125<br>
			155,625<sub>10</sub> = 10011011,101<sub>2</sub> - the number of decimal and binary floating-point<br><br>

			Let the resulting number to the normalized form in decimal and binary system:<br>
			1,55625&#8729;exp<sub>10</sub><sup>+2</sup> = 1,0011011101&#8729;exp<sub>2</sub><sup>+111</sup>
		</p>
		
		<p>As a result, we have the main components of the normalized exponential of binary numbers:<br>
			Mantissa  M=1.0011011101<br> 
			Exponent  exp<sub>2</sub>= +111
		</p>
		
		<h3>§4. Description converting numbers of IEEE 754.</h3>
		<h3>4.1 The transformation of a normalized binary numbers in 32 bit format IEEE 754</h3>
		<p>The main application in technology and programming formats were 32 and 64 bits. <br>
			For example, in VB using the data types single (32 bit) and double (64 bits). <br>
			Consider the transformation of the binary number 10011011.101 format single-precision (32 bit) IEEE Standard 754. <br>
			Other formats of the numbers in IEEE 754 is an enlarged copy of the single-precision.
		</p>
		<p> To provide the number in the format single-precision IEEE 754 should bring it to the binary normalized form.
			In § 3, we have done this conversion on the number 155.625.
			Now consider, as a normalized binary number is converted to a 32-bit format IEEE 754
		</p>
		<ul type="1" start="1">Description of the transformation in 32-bit format IEEE 754:
			<li>Number can be + or -.<br> 
				Therefore play a bit to designate the sign of: <br>
				0-positive <br>
				1-negative <br>
				This most significant bit to 32 bit sequence.

			</li><li>Then go exponent bits, this allocates 1 byte (8 bits).<br> 
				Exhibitor may be, as the number, with the sign + or -. <br> 
				To determine the sign of the exponent, not to introduce yet another sign bit, add the offset to the exponent in half byte 127 (0111 1111). 
				That is, if our exhibit = +7 (111 in binary), then shifted exponent = 7 +127 = 134. And if our exhibitors was -7, then offset Booths = 127-7 = 120. 
				Biased exponent is written in the allotted 8 bits. 
				However, when we will need to obtain an exponential binary numbers, we simply subtract 127 from this byte.

			</li><li>The remaining 23 bits set aside for the mantissa. <br>
				However, the normalized binary mantissa first bit is always 1, since the number is in the range 1 &lt;= M &lt;2. <br>
				There is washed away, burn unit of the allocated 23 bits, so the allocated 23 bits record the remainder of the mantissa.
		</li></ul>
		<table frame="border">
        		<caption>The table shows the decimal number 155.625 in the 32-bit format IEEE754: </caption>
        		<tbody><tr><td>1 bit		</td><td>8 bit		</td><td>23 bit				</td><td>IEEE 754
			</td></tr><tr><td>0		</td><td>1000 0110		</td><td>001 1011 1010 0000 0000 0000   	</td><td>431BA000 (hex)
			</td></tr><tr><td>0(dec)		</td><td>134(dec)		</td><td>1810432(dec)			</td><td>
			</td></tr><tr><td>знак числа	</td><td>offset exponent	</td><td>the remainder of the mantissa	</td><td>  number 155.625 in IEEE754 format
			
		</td></tr></tbody></table>
		<p>As a result of a decimal number 155.625 submitted to the IEEE 754 single precision equal to c 431BA000 (hex).
				
		</p>
		<h3>4.2 Conversion of 32-bit format IEEE 754 to decimal</h3>
		<ul>To write the number in the IEEE 754 standard, or to restore it, you need to know three parameters:
			<li> S-sign bit (31-th bit)
			</li><li> E-offset exponent (bits 30-23)
			</li><li> M - the remainder of the mantissa (bits 22-0)
		</li></ul>
		<p>This whole numbers that are recorded in the number of IEEE 754 in binary form.</p>
		<p>We give a formula for a decimal number from among IEEE754 Single precision:
		</p>
		<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_f1.gif" align="baseline" alt="Formula normalized to 32-bit IEEE754 ">
			where the F - decimal
			
		
		<p>Check our example: <br>
			 F =(-1)<sup>0</sup>&#8729;2<sup>(134-127)</sup>&#8729;(1+ 1810432 / 2<sup>23</sup>)= 2<sup>7</sup>&#8729;(1+0,2158203125)=128&#8729;1,2158203125=155,625
		</p>The derivation of this formula is not going to lead, you can see everything and so. 
 			Shall explain only (1+ M/2<sup>23</sup>) -a mantissa, a unit in this formula is that the unit, which we threw out of 23 bits, and the rest of mantissa in the decimal form we find a ratio of two integers - the balance of the mantissa to the whole.
		
		<h3>§5. Formal representation of numbers in the IEEE to 754 in any format accuracy.</h3>
		<p>Fig. 1 Presentation format of the IEEE 754</p>
		<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_1.gif" align="baseline" alt="Format numbers IEEE754"><br>
		
	
		
		<ul>where:
			<li>S - number of bits S = 0 - positive number; S = 1 - negative number
			</li><li> - offset exponent;<br>
				  exp<sub>2</sub> = E - (2<sup>(b-1)</sup> - 1) - exponential binary normalized floating point<br>
				  (2<sup>(b-1)</sup> -1)  - given the shift exponent (32-bit ieee754 it is equal to 127 see above)
			</li><li>M - the rest of the mantissa of a normalized binary floating point numbers
		</li></ul>
		
		<h4>Formula for calculating the decimal floating point numbers, the numbers presented in the standard IEEE754:</h4>
		<p><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_f2.gif" align="baseline" alt="Formula normalized numbers IEEE754 ">(Formula  1)</p>
		<p>Using the formula we calculate a formula for finding a decimal to a single (32 bit) and double (64 bits) of accuracy the number recorded in the IEEE 754 standard:</p>
		<p>Fig.2 The format of single-precision (single-precision) 32-bit<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_2.gif" align="baseline" alt="Format 32-bit numbers normalizovanyh IEEE754 "></p><br>
		<p>Fig.3 The format of a double-precision (double-precision) 64-bit<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_3.gif" align="baseline" alt="Format 64-bit numbers normalizovanyh IEEE754 "></p>
		
		<h3>§6. Exceptional number of the IEEE 754</h3>
		<ul>If you apply a formula to calculate the minimum and maximum numbers of single-precision presented in IEEE754, we obtain the following results:
			<li><font face="Courier New">00 00 00 00 hex= 5,87747175411144e-39 (minimum positive number)</font>
			</li><li><font face="Courier New">80 00 00 00 hex=-5,87747175411144e-39 (minimum negative number)</font>
			</li><li><font face="Courier New">7f ff ff ff hex= 6,80564693277058e+38 (maximum positive number)</font>
			</li><li><font face="Courier New">ff ff ff ff hex=-6,80564693277058e+38 (maximum negative number)</font>
		</li></ul>
		<p>This shows that it is impossible to provide the number of zero or infinity in the given format.</p>
		<h4>Therefore, the standard exceptions made and the formula number 1 does not apply in the following cases:</h4>
		<p>1. Number IEEE754=00 00 00 00hex   is the number  +0<br> 
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_4.gif" align="baseline" alt="Number +0 in 32-bit IEEE754 "><br>
		   Number IEEE754=80 00 00 00hex   is the number  -0<br> 
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_5.gif" align="baseline" alt="Number -0 in 32-bit IEEE754 "></p>		
		<br><br>
		<p>2. Number  IEEE754=7F 80 00 00hex  is the number +&#8734;<br> 
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_6.gif" align="baseline" alt="Number +&#8734; in 32-bit IEEE754 "><br>
			Number  IEEE754=FF 80 00 00hex  is the number   -&#8734;<br> 
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_7.gif" align="baseline" alt="Number -&#8734;in 32-bit IEEE754 "></p>
		<br><br>
		<p>3. Numbers  IEEE754=FF (1xxx)X XX XXhex  not considered numbers  (NAN), unless p.2<br>
			 &nbsp; &nbsp; Numbers  IEEE754=7F (1xxx)X XX XXhex  not considered numbers (NAN), unless p.2<br> 
			The number represented in bits from 0 ... 22 can be any number except 0 (+&#8734; и -&#8734; ).<br>
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_8.gif" align="baseline" alt="number of NAN in 32-bit IEEE754 "></p>
		<br>
		<p>4. Numbers  IEEE754=(x000) (0000) (0xxx)X XX XXhex  are denormalized numbers, except numbers p.1( -0 and +0)<br> 
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_9.gif" align="baseline" alt="denormalized numbers in 32-bit IEEE754 "></p>
		<h3>The formula denormalized numbers:</h3>
		<p><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_f3.gif" align="baseline" alt="The formula for 32bit denormalized IEEE754 ">(Formula 2)</p>
		<ul type="1" start="1"><strong>Explanations for the exceptional numbers:</strong>
			<li>Since zero is understandable. Without it they can. Confused by the presence of two zeros. I think this was done for symmetry.
			</li><li>- &#8734;/ +&#8734;  Also understandable.The numbers that are greater than limits the range of representation of numbers is infinite.
			</li><li>No number of NAN (No a Numbers). These are the characters, or the results invalid operations.
			</li><li>Denormalized numbers. This number, mantissa which lie in the range 0.1 &lt;= M &lt;1.<br>
				Denormalized numbers are closer to zero than normalized.
				Denormalized numbers as the minimum level to break the normalized number to a subset.
				Made this because of technical practices are more common values close to zero.
		</li></ul>
		<br>
		<h3>§7.  Data on the number of single and double precision represented in the IEEE 754.</h3>
<h3>7.1  Calculating limits the range for single-precision numbers of IEEE 754. </h3>
		<p>Given the format of numbers with single precision IEEE Standard 754 can calculate the range for the submission of real numbers in this format.
			For this we substitute the values of maximum and minimum absolute numbers of IEEE 754 in formula 1 and 2</p>
		<p>The minimum number of normalized (absolute)<br>
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_10.gif" align="baseline" alt="minimum normalized number in 32-bit IEEE754 "><br>
			00 80 00 00 = 2<sup>-126</sup>&#8729;(1+0/2<sup>23</sup>)= 2<sup>-126</sup> &#8776;  1,17549435&#8729;e<sup>-38</sup><br>
			80 80 00 00 = -2<sup>-126</sup>&#8729;(1+0/2<sup>23</sup>)=2<sup>-126</sup> &#8776; -1,17549435&#8729;e<sup>-38</sup><br> 
		<br><br>	
		Maximum denormalizovanoe number (absolute)<br>
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_11.gif" align="baseline" alt="Maximum denormalized numbers in 32-bit IEEE754 "><br>
			00 7F FF FF = 2<sup>-126</sup>&#8729;(1-2<sup>-23</sup>)  &#8776; 1,17549421&#8729;e<sup>-38</sup><br>
			80 7F FF FF = -2<sup>-126</sup>&#8729;(1-2<sup>-23</sup>)  &#8776; -1,17549421&#8729;e<sup>-38</sup><br>
			
		This shows that the minimum normalized number of borders with a maximum denormalized.
		</p>
		<br><br>
		<p>Minimum denormalized number (absolute)<br>
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_12.gif" align="baseline" alt="minimum denormalized numbers in 32-bit IEEE754 "><br>
			00 00 00 01 = 2<sup>-126</sup>&#8729; 2<sup>-23</sup>=  2<sup>-149</sup>   &#8776;  1,40129846&#8729;e<sup>-45</sup><br>
			80 00 00 01 = -2<sup>-126</sup>&#8729;-2<sup>-23</sup>=  2<sup>-149</sup>   &#8776;  -1,40129846&#8729;e<sup>-45</sup><br>
			This number is bounded by zero.</p>
		<br><br>
		<p>Maximum number of normalized (absolute)<br>
			<img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_13.gif" align="baseline" alt="the maximum normalized number in 32-bit IEEE754 "><br>
			7F 7F FF FF =  2<sup>127</sup>&#8729;(2-2<sup>-23</sup>) &#8776;     3,40282347&#8729;e<sup>+38</sup><br>
			FF 7F FF FF =  -2<sup>127</sup>&#8729;(2-2<sup>-23</sup>) &#8776;    -3,40282347&#8729;e<sup>+38</sup><br>
			That number is bordered with infinity. </p>
		<br><br>

<h3>7.2 Full range of single-precision numbers (32 bit) standard IEEE754</h3>
		<p>Рис.The range of numbers the format single-precision (32 bits) represented by the IEEE 754<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_14_en.gif" align="baseline" alt="range of numbers in 32-bit IEEE754 "><br></p>
		
<h3>7.3 Full range of double-precision numbers (32 bit) standard IEEE754</h3>
		<p>Fig.5 .The range of numbers the format double-precision (32 bits) represented by the IEEE 754<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_14_1.gif" align="baseline" alt="range of numbers in 64-bit IEEE754 "><br></p>
		
<h3>7.4 Accuracy of the representation of real numbers in the format of IEEE754.</h3>
		<p>The numbers presented in the format IEEE754 represent a finite set, which displays an infinite set of real numbers.
			 Therefore, the original number can be represented in IEEE754 format with an error.
	         	</p>
			<p>Fig.6 Error function exactly represent the number of IEEE754 <br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_15.gif" align="baseline" alt="error in the representation of the accuracy of IEEE754 "><br></p>
			<p>Absolute maximum error for the number in the format IEEE754 is within half a step numbers.
				Step numbers doubled with an increase in the exponent of the binary number by one.
				That is, the farther away from zero, the greater the step numbers in IEEE754 format on the real axis.<br>
				Step number is equal to the lowest level <strong> 2<sup>(E-22-127)</sup>=2<sup>(E-149)</sup></strong> (Single) и <strong>2<sup>(E-51-1023)</sup>= 2<sup>(E-1074)</sup> </strong>(Double).<br>
				Accordingly, limit the maximum absolute error is 1 / 2 steps of:<strong>2<sup>(E-150)</sup></strong> (Single) и <strong>2<sup>(E-1075)</sup></strong> (Double).<br>
				Relative error in% will be:  <strong>(2<sup>(E-150)</sup>/F)*100%</strong>(Single) и <strong>(2<sup>(E-1075)</sup>/F)*100%</strong> (Double).<br>
			</p>
			
			<p>The maximum relative error for denormalized numbers (single / double): <br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_16.gif" align="baseline" alt="relative error of denormalized numbers IEEE754 "><br></p>
			<p>The maximum relative error of the normalized number of (single): <br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_17.gif" align="baseline" alt="relative error of denormalized numbers IEEE754 "><br></p>
			<p>The maximum relative error of the normalized number (double): <br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_18.gif" align="baseline" alt="relative error of denormalized numbers IEEE754 "><br></p>
		<table frame="border">
        		<caption>Table 1. The maximum possible error for the number of Single</caption>
        		<tbody><tr><td>IEEE754, hex	</td><td>Number, dec		</td><td>absolute error, dec </td><td> relative , %
			</td></tr><tr><td>00000001	</td><td>2<sup>-149</sup> &#8776;1,401298e-45</td><td>2<sup>-150</sup>&#8776;0,700649e-45 </td><td>=50
			</td></tr><tr><td>00000002	</td><td>2<sup>-148</sup> &#8776;2,802597e-45</td><td>2<sup>-150</sup>&#8776;0,700649e-45  </td><td>=25
			</td></tr><tr><td>00000032	</td><td>&#8776;7,00649e-44</td><td>2<sup>-150</sup>&#8776;0,700649e-45  </td><td>=1
			</td></tr><tr><td>007FFFFF	</td><td>&#8776;1,175494e-38</td><td>2<sup>-150</sup>&#8776;0,700649e-45  </td><td>&#8776;5,96e-6
			</td></tr><tr><td>00800001	</td><td>&#8776;1,175494e-38</td><td>2<sup>-149</sup> &#8776;1,401298e-45  </td><td>&#8776;11,9209e-6
			</td></tr><tr><td>0DA24260	</td><td>&#8776;1,0e-30</td><td>2<sup>-123</sup> &#8776;9,4039e-38  </td><td>&#8776;9,4039e-6
			</td></tr><tr><td>1E3CE508	</td><td>&#8776;1,0e-20</td><td>2<sup>-90</sup> &#8776;8,0779e-28   </td><td>&#8776;8,0779e-6
			</td></tr><tr><td>2EDBE6FF	</td><td>&#8776;1,0e-10</td><td>2<sup>-57</sup> &#8776;6,9389e-18   </td><td>&#8776;6,9389e-6
			</td></tr><tr><td>3F800000	</td><td>&#8776;1,0</td><td>2<sup>-23</sup> &#8776;1,192e-7         </td><td>&#8776;11,9209e-6
			</td></tr><tr><td>41200000	</td><td>&#8776;10,0</td><td>2<sup>-20</sup> &#8776;9,5367e-7        </td><td>&#8776;9,5367e-6
			</td></tr><tr><td>42C80000	</td><td>&#8776;1,0e+2</td><td>2<sup>-17</sup> &#8776;7,6294e-6       </td><td>&#8776;7,62939e-6
			</td></tr><tr><td>501502F9	</td><td>&#8776;1,0e+10</td><td>2<sup>10</sup> &#8776;1,024e+3       </td><td>&#8776;10,24e-6
			</td></tr><tr><td>60AD78EC	</td><td>&#8776;1,0e+20</td><td>2<sup>43</sup> &#8776;8,7961e+12       </td><td>&#8776;8,7961e-6
			</td></tr><tr><td>7149F2CA	</td><td>&#8776;1,0e+30</td><td>2<sup>76</sup> &#8776;7,5558e+22       </td><td>&#8776;7,5558e-6
			</td></tr><tr><td>7F7FFFFF	</td><td>&#8776;+3,40282e+38</td><td>2<sup>104</sup> &#8776;2,02824e+31       </td><td>&#8776;5,96e-6
		</td></tr></tbody></table><br>

		<table frame="border">
        		<caption>Table 2. The maximum possible error for the numbers of Double </caption>
        		<tbody><tr><td>IEEE754, hex	</td><td>Number, dec		</td><td>absolute error, dec </td><td> relative, %
			</td></tr><tr><td>00000000 00000001	</td><td>2<sup>-1074</sup> &#8776;4,940656e-324</td><td>2<sup>-1075</sup>&#8776;2,470328e-324 </td><td>=50
			</td></tr><tr><td>00000000 00000002	</td><td>2<sup>-1073</sup> &#8776;9,881313e-324</td><td>2<sup>-1075</sup>&#8776;2,470328e-324 </td><td>=25
			</td></tr><tr><td>00000000 00000032	</td><td>&#8776;2,470328e-322</td><td>2<sup>-1075</sup>&#8776;2,470328e-324 </td><td>=1
			</td></tr><tr><td>000FFFFF FFFFFFFF	</td><td>&#8776;2,225073e-308</td><td>2<sup>-1075</sup>&#8776;2,470328e-324 </td><td>&#8776;1,110223e-14
			</td></tr><tr><td>00100000 00000001	</td><td>&#8776;2,225074e-308</td><td>2<sup>-1074</sup> &#8776;4,940656e-324  </td><td>&#8776;2,220446e-14
			</td></tr><tr><td>2B2BFF2E E48E0530	</td><td>&#8776;1,0e-100</td><td>2<sup>-385</sup> &#8776;1,268971e-116 </td><td>&#8776;1,268971e-14
			</td></tr><tr><td>3FF00000 00000000	</td><td>=1,0</td><td>2<sup>-52</sup> &#8776;2,220446e-16  </td><td>&#8776;2,220446e-14
			</td></tr><tr><td>54B249AD 2594C37D	</td><td>&#8776;1,0e+100</td><td>2<sup>280</sup> &#8776;1,942669e+84  </td><td>&#8776;1,942669e-14
			</td></tr><tr><td>6974E718 D7D7625A	</td><td>&#8776;1,0e+200</td><td>2<sup>612</sup> &#8776;1,699641e+184        </td><td>&#8776;1,699641e-14
			</td></tr><tr><td>7FEFFFFF FFFFFFFF	</td><td>&#8776;1,79769e+308</td><td>2<sup>971</sup> &#8776;1,99584e+292       </td><td>&#8776;1,110223e-14
			
		</td></tr></tbody></table>
		<p>From the above, given that the bulk of the numbers in IEEE754 format has a stable small relative error:
			The maximum possible relative error for the number is  Single 2<sup>-23</sup>*100% =11,920928955078125e-6 %<br>
			The maximum possible relative error for the number of Double 2<sup>-52</sup>*100% =2,2204460492503130808472633361816e-14 %<br>

		</p>
		<br><br>

		<h3>7.5 General information for the number of single and double precision IEEE standard 754.</h3>
		<table frame="border">
        		
		<caption>Table 3. Information about the format 32/64 bit in the standard ANSI / IEEE Std 754-1985</caption>
        		<tbody><tr><td>Name format		</td><td>single-precision		</td><td>double-precision
			</td></tr><tr><td>length number, bit	</td><td>32			</td><td>64
			</td></tr><tr><td>offset the exponential (E), bits	</td><td>8			</td><td>11
			</td></tr><tr><td>the remainder of the mantissa (M), bits	</td><td>23			</td><td>52
			</td></tr><tr><td>bias			</td><td>127			</td><td>1023
			</td></tr><tr><td>denormalized binary number	</td><td>(-1)<sup>S</sup>&#8729;0,M&#8729;exp<sub>2</sub><sup>-127 <small>,where M-binary</small></sup></td><td>(-1)<sup>S</sup>&#8729;0,M&#8729;exp<sub>2</sub><sup>-1023 <small>,где  M-бинарное</small></sup>
			</td></tr><tr><td>normalized binary number	</td><td>(-1)<sup>S</sup>&#8729;1,M&#8729;exp<sub>2</sub><sup>(E-127) <small>,where M-binary</small></sup>	</td><td>(-1)<sup>S</sup>&#8729;1,M&#8729;exp<sub>2</sub><sup>(E-1023) <small>,где  M-бинарное</small></sup>
			</td></tr><tr><td>denormalized number of decimal			</td><td>F =(-1)<sup>S</sup>&#8729;2<sup>(E -126)</sup>&#8729; M/2<sup>23</sup>		</td><td>F =(-1)<sup>S</sup>&#8729;2<sup>(E -1022)</sup>&#8729;M/2<sup>52</sup>
			</td></tr><tr><td>normalized number of decimal			</td><td>F =(-1)<sup>S</sup>&#8729;2<sup>(E-127)</sup>&#8729;(1+ M/2<sup>23</sup>)		</td><td>F =(-1)<sup>S</sup>&#8729;2<sup>(E-1023)</sup>&#8729;(1+M/2<sup>52</sup>)
			
			</td></tr><tr><td>Abs. max. error number </td><td>2<sup>(E-150)</sup>		</td><td>2<sup>(E-1075)</sup>
			</td></tr><tr><td>Rel. max. error denorms. number</td><td>1/(2M)		</td><td>1/(2M)
			</td></tr><tr><td>Rel. max. error norms. number</td><td>1/(2<sup>24</sup>+2M)		</td><td>1/(2<sup>53</sup>+2M)
			</td></tr><tr><td>Min Number					</td><td>±2<sup>-149</sup>&#8776; ±1,40129846&#8729;e<sup>-45</sup>			</td><td>±2<sup>-1074</sup>&#8776;  ± 4,94065646&#8729;e<sup>-324</sup>
			</td></tr><tr><td>Max Number					</td><td>±2<sup>127</sup>&#8729;(2-2<sup>-23</sup>) &#8776;  ± 3,40282347&#8729;e<sup>+38</sup>		</td><td>±2<sup>1023</sup>&#8729;(2-2<sup>-52</sup>) &#8776;  ± 1,79769313&#8729;e<sup>+308</sup>
		</td></tr></tbody></table>
		<br><br>
<h3>§8. Rounding numbers in standard IEEE 754.</h3>
		
		<p>In presenting the floating-point numbers in IEEE Standard 754 have often rounded numbers.
			The standard provides four ways to rounding of numbers. 
		</p>
		<ul type="1" start="1"><strong>Ways to rounding of numbers of IEEE 754:</strong>
			<li>Rounding tending to the nearest integer.
			</li><li>Rounding tends to zero.
			</li><li>Rounding tends to +&#8734;
			</li><li>Rounding tends to -&#8734;
		</li></ul>
		<table frame="border">
        		<caption>Table 3. Examples of rounding to one decimal</caption>
        		<tbody><tr><td>original number	</td><td>to the nearest integer	</td><td>zero	</td><td>to +&#8734;	</td><td>to -&#8734;
			</td></tr><tr><td>1,33		</td><td>1,3		</td><td>1,3		</td><td>1,4		</td><td>1,3
			</td></tr><tr><td>-1,33		</td><td>-1,3	</td><td>-1,3	</td><td>-1,3	</td><td>-1,4
			</td></tr><tr><td>1,37		</td><td>1,4		</td><td>1,3		</td><td>1,4		</td><td>1,3
			</td></tr><tr><td>-1,37		</td><td>-1,4	</td><td>-1,3	</td><td>-1,3	</td><td>-1,4
			</td></tr><tr><td>1,35		</td><td>1,4		</td><td>1,3		</td><td>1,4		</td><td>1,3
			</td></tr><tr><td>-1,35		</td><td>-1,4	</td><td>-1,3	</td><td>-1,3	</td><td>-1,4
			
		</td></tr></tbody></table>
		<p>How is rounding shown in the examples in Table 3. 
			When you convert a number to choose one of the ways of rounding. 
			By default, this is the first way, rounding to the nearest integer. 
			Often in different devices using the second method - rounded to zero. 
			When rounding to zero, simply discard meaningless level numbers, so this is the easiest one in the hardware implementation.
		</p>

<h3>§9. Computing problems caused by using the standard IEEE754.</h3>
	           <p>IEEE 754 standard is widely used in engineering and programming. <br>
			 Most modern microprocessors are manufactured with hardware realization of representations of real variables in the format of IEEE754. <br>
			 Programming language and the programmer can not change this situation, a repose of a real number in the microprocessor does not exist. <br>
 			When creating the standard IEEE754-1985 representation of a real variable in the form of 4 or 8 bytes seem very large value, since the amount of RAM MS-DOS was equal to 1 MB.
			 A program in this system could be used only 0.64 MB.
 			For modern operating systems the size of 8 bytes is null and void, nevertheless the variables in most microprocessors continue to be in the format IEEE754-1985. <br>
	           </p>
	           

		<p>Consider the error computing, caused by the use of numbers in the format of IEEE754
		</p>
	
<h3>9.1 Errors associated with accuracy of representation of real numbers in the format of IEEE754. A dangerous reduction.</h3>
		<p>This error is always present in computer calculations. <br>
			 The reason for its occurrence is described in paragraph 7.4. <br i="" am="" glad="" only="" that="" the="" relative="" error="" has="" dimensions="" for="" single="" 10<sup="">-6 for double 10<sup>-14</sup><br>
			The absolute errors can be significant, as for single 10<sup>31</sup> and for double 10<sup>292</sup>,that may cause problems with calculations.
		</p>
		<pre>//Example 1. Error due to the precision of numbers in IEEE754 format
		#include "stdio.h"
		
    		int
		main(int argc, char *argv[])
		{    
			float a, b, f;
			a=123456789;
			b=123456788;     
			f=a-b;	
        		printf("Result: %f\n", f);
     			return 0;

		}
		Result: 8.000000  (The answer should be 1.000000)
		</pre>
		<p>If the sample count on the paper, the answer is 1. Absolute error is +7. <br>
 			Why get the wrong answer? <br>
 			Number 123456789 in the single = 4CEB79A3hex (ieee) = 123456792 (dec) absolute error reporting is +3 <br>
			 Number 123456788 in the single = 4CEB79A2hex (ieee) = 123456784 (dec) absolute error reporting is -4 <br>
 			Relative error in the initial numbers of approximately 3,24 e-6% <br>
			 As a result, one operation relative error of the result was 800%, ie increased by 2,5 e +8 times. <br>
		This is what I call<strong>"A dangerous reduction"</strong>, ie catastrophic decrease of accuracy in the operation where the absolute value of the result is much smaller than any of the input variables.
		</p>
		
		<p>In fact, the error precision of the representation of the most innocuous in computer calculations, and usually many programmers are not paying any attention.
 			Nevertheless, they you can be very frustrating.
		</p>
<h3>9.2 Errors associated with improper coercion of types of data. Wild error.</h3>
		<p>These errors are caused by the fact that the original number submitted in the format of single and double in a format not usually equal to each other. <br>
 			For example: the original number 123456789,123456789 <br>
 			Single: 4CEB79A3 = +123456792,0 (dec) <br>
 			Double: 419D6F34547E6B75 = +123456789,12345679104328155517578125 <br>
 			The difference between Single and Double amount: 2,87654320895671844482421875 <br>
		</p>
	Here is an example for VB:<br>
	<pre>	Private Sub Command1_Click()
    			Dim a As Single
    			Dim b As Double
    			Dim c As Double
    
    			a = 123456789.123457
    			b = 123456789.123457
    			c = a - b
    			Text1.Text = c
    
		End Sub
	The result: 2.87654320895672 (should be 0)
	</pre>
	Relative error of the result is:<big>&#8734;</big> (infinity)<br>
	This error is called a "dirty zero".<br>

	If the variables lead to the same type, then this error will not happen.<br>
	<pre>		Private Sub Command1_Click()
    			Dim a As Single
    			Dim b As Single
    			Dim c As Single
    
    			a = 123456789.123457
    			b = 123456789.123457
    			c = a - b
    			Text1.Text = c
    
		End Sub
	Result: 0.0
	</pre>
	Therefore, variables and intermediate results of computations to be brought to the same data type. <br>
 	For example, the requirement of showing the same type described in the standard C language to ISO / IEC 9899:1999. <br>
	<p>Pay attention to the fact that not enough just to bring all the original data to a single type.
		 Necessary to bring the results of intermediate operations to the same type. <br>
 		Here is an example of an error in the intermediate result:
	</p>
	<pre>'Example 1 error in the intermediate data in VB (Visual Studio)
		Private Sub Command1_Click()
    			Dim a As Single
    			Dim b As Single
    			Dim c As Single
    
    			a = 1
    			b = 3
    			c = a / b
    			c = c - 1 / 3
    			Text1.Text = c
    
		End Sub
	Result: 9,934108 E-09 (Must be 0.0)
	</pre>
		Here the error arises because the intermediate result of 1 / 3 in the line c = c-1 / 3 will be of type double, not single.
 		To get rid of the error you have to give an intermediate result to the type of single operator using cast CSng.
	<pre>'Example 2 The intermediate data to VB (Visual Studio)
		Private Sub Command1_Click()
    			Dim a As Single
    			Dim b As Single
    			Dim c As Single
    
    			a = 1
    			b = 3
    			c = a / b
    			c = c - CSng(1 / 3)
    			Text1.Text = c
    
		End Sub
	Result: 0.0
	</pre>

		

			An example of bringing data type for GNU C, sent by Gregory Sitkarevym:<br>

	<pre>		//Option 1 is not listed with an intermediate result:
		#include "stdafx.h"
		#include "stdlib.h"
		#include "stdio.h"
		#include "math.h"

		int
		main(int argc, char *argv[])
		{
       		 float a, b, c, d;
        		a = 1.0;
       		 b = 3.0;
        		c = a / b;
        		d = (c - 1.0/3.0) * 1.0e9;//the result of dividing 1 / 3 has a double type
       		 printf("Result: %f\n", d);
        		return 0;
		}
		Result: 9.934108 (Must be 0.0)

		//Option 2 with the above intermediate results:
		#include "stdafx.h"
		#include "stdlib.h"
		#include "stdio.h"
		#include "math.h"

		int
		main(int argc, char *argv[])
		{
        		float a, b, c, d;
        		a = 1.0;
        		b = 3.0;
        		c = a / b;
        		d = (c - 1.0f/3.0f) * 1.0e9f;//the result of dividing 1 / 3 cast to float
       		 printf("Result: %f\n", d);
        		return 0;
		}
		Result: 0.0

	</pre>

	<p>In the second version you can see that the division of the constants in the intermediate result is given to the type of "float" (single precision in C).
		 These options were compiled and executed using the "GNU C". <br>
		 If you compile and execute the above options are shown on the VC + + (Visual Studio), the results would be reversed.
 		That is, option 2 would be the result of -9.934108, and option 1 Result: 0.000000. <br>
		 Hence it can be disappointing conclusion that the result of calculations may depend on the type and version of the compiler.
		 In this case, we can assume that the VC + + compiler automatically gives the types of variables, and the attempt to forcibly bring the same type fails.
	</p>
	<p>If Option 1 (without the cast) to meet with variable double-precision (double), then the error will not bring data and Result = 0.000000 <br> 
		So in most cases to get rid of the cast data is simply to use the data type double and forget about the type of single (float). <br> 
		Computational errors caused by not bringing the type of data I call the "Wild errors" as they relate to the ignorance of the standards and the theory of programming (ie, with poor basic education)
	</p>

<h3>9.3 Errors caused by the shift of the mantissa. Circular holes.</h3>
		These errors are associated with loss of accuracy of the result in incomplete mantissas intersection numbers on the real axis. <br>
 		If the mantissa numbers do not intersect on the real axis, then addition and subtraction between these numbers are impossible. <br>
 		For example, we take the number of Single: 47FFFFFF = +131071,9921875 (dec) <br>
		 In the binary system, this number looks like: +11111111111111111,1111111 <br> <br>
		 We show some computer operations of addition, and this number in the format of Single <br>
		 Significant digits in the mantissa of the binary number in the format of Single no more than 24 <br>
 		Red indicates the figures beyond this limit and are not involved in the format Single

		
		<p>1. addition with the same number (the error shift = 0.0).<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_19.gif" align="baseline" alt=" "><br></p>
		<p>2. addition to the number of smaller 2-fold (error = shift - 0.00390625).<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_20.gif" align="baseline" alt=" "><br></p>
		<p>3. addition with a smaller number of 2<sup>23</sup>  times (error shift = - 0.007812).<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_21.gif" align="baseline" alt=" "><br></p>
		<p>4. addition with a smaller number of 2<sup>24</sup>  times (error shift= - 0.007812).<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_22.gif" align="baseline" alt=" "><br></p>
		In the latter case the mantissa of numbers separated, and arithmetic operations with these numbers are meaningless.<br>
		<p>As can be seen from the above examples shift error occurs if the initial normalized numbers are different exponent.
			If the numbers differ by more than 2<sup> 23 </sup> (for single) and 2 <sup> 52 </sup> (for double), then addition and subtraction between these numbers are not possible. <br>
			 Maximum relative error result of the operation is about 5,96 e-6%, which does not exceed a relative error of representation of the number (p.9.1).
		</p>
		<p>Although the relative error here is all right, there are other problems. <br> 
			First, work with numbers only in a narrow range of the real axis, where the mantissa intersect. <br> 
			Secondly, for each source of the limit of a loop called <strong> "Cyclic hole" </strong>. 
			Let me explain, if there is a cycle in which the original number is added to the sum, there is a numerical limit on the amount for this number. 
			That is, the amount reaching a certain size ceases to increase by adding it to the original number.
		</p>

		<p>Here is an example of a cyclic holes in the automatic control system: <br>
 			There is a pharmaceutical plant producing tablets weighing 10 mg. <br>
 			Consisting of: forming machine, storage tank of 500 kg, packaging machines, automatic control system. <br>
 			Molding machine feeds into the bunker on 10 tablets at a time.
 			Filling machine takes one pill. <br>
 			The automatic control system takes into account the tablets received in the hopper of the molding machine and taken out of the bunker packaging machines.
 			That is, there is a program that shows the filling hopper production in kg.
 			When in the bunker will be over 500 kg product molding machine stands on a break, it includes the code in the bunker will be 200 kg of product.
 			Filling machine to stop if the bunker is less than 10 pounds and will start when the bunker will be over 100 kg product. <br>
			 Both cars can stop from time to serve, not dependent on each other (thanks to the bunker).
		</p>
		<p>Here is an example of a cyclic holes in the automatic control system: <br>
			 There is a pharmaceutical plant producing tablets weighing 10 mg. <br>
			 Consisting of: forming machine, storage tank of 500 kg, packaging machines, as you know, it works in an endless loop. <br>
 			Suppose one day filling machine stood too long and a bunker filled with up to 300 kg. <br>
			 What happens after I turn it on?
		</p>
		
		A simplified example of the program cycle management:
		<pre>	Private Sub Command1_Click()
   		Dim a As Single 'tablet weight in kg
    		Dim c As Single 'product in the hopper in kg
    		Dim n As Long 'number of cycles
    
    		c = 300 'initial weight hopper
    		a = 0.00001 'tablet weight
    
    		For n = 1 To 10000000
        		c = c - a 'one tablet is taken packaging machines
    		Next n
    		Text1.Text = c 'modified weight hopper
	End Sub
		</pre>
		In this example, the filling machine picked up from the hopper 100 kg of product, and the weight of products in the hopper has not changed. <br>
		 Why not change? <br>
 		Because the mantissa numbers 300 and 0.00001 disjoint format single.
		<p>Next, bring the weight of the molding machine hopper to 500 kg and stop.
 			Filling machine will take all the tablets from the hopper and also stops.
			 The program will show the weight of 500kg in the bunker.
 			Come running specialists, test sensors, wires, computer, and say that the program hung.
 			But the program does not hang, it continues to run smoothly and every check will confirm this.
 			Simply the number of 0.0001 hit in the cyclic hole and emerge from it can not.
		</p>
		<p>As a result, we were lucky that it was a pharmaceutical plant, not the Sayan-Shushenskaya GES.

		</p>
		<p>In fact, an experienced programmer would never make a cyclic subtraction (or summation) in this way.
 			This example is fictitious purpose, and so can not be considered, although in terms of mathematics are all flawlessly.
 			This error is typical of mathematicians and novice programmers. <br>
			 I would say that the main work of the programmer is to struggle with errors, but not in the mathematical solution to the problem.	
		</p>
		Here is an example of a correct solution to this problem, courtesy of Sitkarevym Gregory:

		<pre>	#include "stdlib.h"
	#include "stdio.h"
	#include "math.h"

	struct acc_comp {
				float value;
				float compens;
			};

	void
	sub_compens(struct acc_comp *acc, float quantum)
		{
			float tmp, c;

			tmp = quantum - acc-&gt;compens;
			c = acc-&gt;value - tmp;
			acc-&gt;compens = acc-&gt;value - c - tmp;
			acc-&gt;value -= tmp;
		}

	void
	sum_compens(struct acc_comp *acc, float quantum)
		{
			float tmp, c;

			tmp = quantum - acc-&gt;compens;
			c = acc-&gt;value + tmp;
			acc-&gt;compens = c - acc-&gt;value - tmp;
			acc-&gt;value += tmp;
		}

	void
	sub_test()
		{
			struct acc_comp hopper;
			struct acc_comp bunker;
			float tablet;
			int n, i;

			n = 10000000;
			hopper.value = 300.0;
			hopper.compens = 0.0;
			bunker.value = 0.0;
			bunker.compens = 0.0;
			tablet = 0.00001;

			for (i = 0; i &lt; n; i++) 
				{
					sub_compens(&amp;hopper, tablet);
					sum_compens(&amp;bunker, tablet);
				}

			hopper.value -= hopper.compens;
			bunker.value += bunker.compens;

			printf("Left in hopper: %04.5f kg\n", hopper.value);
			printf("Held in bunker: %04.5f kg\n", bunker.value);
		}

	int
	main(int argc, char *argv[])
		{
			sub_test();

			return 0;
		}

		</pre>
	The preceding example is taken from real industrial package. <br>
	 For clarity, we simplify the above example. <br>
<pre>	#include "stdlib.h"
	#include "stdio.h"
	#include "math.h"

	float bunker, bunker1, tablet, tablet1, compens;
	long int n, i;

	int
	main(int argc, char *argv[])
		{
			tablet = 0.00001; /* tablet weight */
			tablet1 = 0.0; /* tablet weight in view of errors in previous iterations */
			bunker = 300.0; /* initial weight hopper */
			bunker1 = 0.0; /* weight of the hopper after the next iteration */
			compens = 0.0; /* compensation weight loss pills */

			n = 10000000; /*number of cycles */

			for (i = 0; i &lt; n; i++) 
			  {
				/* tablet weight-compensated error */
				tablet1 = tablet - compens;
				/*weight of the hopper after deducting compensated tablets*/
				bunker1 = bunker - tablet1;
				/* calculation of compensation for the next iteration */
				compens = (bunker - bunker1) - tablet1;
				/*new weight hopper */
				bunker = bunker - tablet1;
			  }

			printf("Bunker: %04.5f kg\n", bunker);

			return 0;
		}
 

</pre>
As can be seen from this example, the programmer has to calculate the error of the result in each cycle, to account for it in the next cycle. <br>
 Note that the programmer should be absolutely ready to make some basic concepts of mathematics can not be satisfied in the calculations in a format IEEE754.
 For example, the rules of algebraic commutativity (a + b) + a = (a + c) + b, is usually not performed in these calculations. <br>
 Unfortunately, in today's fundamental education that is receiving very little attention.


<h3>9.4 Errors due to rounding. Dirty zero.</h3>
		<p>When computer calculations can distinguish two types of rounding: <br>
 			1. The result of arithmetic operation is always rounded. <br>
		 	2. Output and input of a real number in the box Windows is rounded. <br>	
		</p>
		<p>In the first case, the variable is rounded to one of 4 types of rounding IEEE754, the default rounding occurs to the nearest integer. <br>
 			In this case, the variable receives a new rounded value. <br>
			 In p.9.2 we considered the addition of two identical numbers:
		</p><p>1. Addition with the same number (the error shift = 0.0). <br> <img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_19.gif" align="baseline"> <br> <!-- p-->
 			Here the result of the addition of two numbers is absolutely accurate, but the result was rounded off by a microprocessor.
 			Thus, to the exact result has been added to rounding error. In general, the rounding error is within the accuracy of the numbers.
		</p>
		<p>In the second case, the variable does not change its meaning, just in Windows window displays the rounded value of the real numbers.
 			It turns out that the original variable and displaying it in Windows is a different number.
 			This is not the fault of the format IEEE754, this is a bug Windows. <br>
		Single variable is displayed in the Windows 7 significant figures rounded to nearest whole number. <br>
			 3DFCD6EA = +0,12345679104328155517578125 box is displayed as 0,1234568 <br>
 			For variables of type Double to a Windows box displays 15 significant digits rounded to the nearest whole number. <br>
 			3FBF9ADD3746F67D = +0,12345678901234609370352046653351862914860248565673828125 displayed as 0.123456789012346<br><br>

		The question of how important variable when we enter into the window Windows 0,123456789012346? <br>
 		This value will be equal to this number: <br>
 		3FBF9ADD3746F676 = +0,1234567890123459965590058118323213420808315277099609375 <br>
		 That is, the value of 3FBF9ADD3746F67D we generally can not insert directly into the program code. <br>
 		But we can cheat and paste into the x = 0.123456789012346 +1 E-16.
		 The resulting variable will be equal to 3FBF9ADD3746F67D (this is used in the example of dirty zero) <br>
		 Display or to a PC through the window is a number impossible.
		
		</p>
		<p>As a result of action arises Windows a number of unpleasant situations. <br>
			 1. You do not have technical capability to display or enter the exact values ??of the variables in the windows, which in itself is very sad. <br>
			 2. The emergence of serious errors, such as dirty zero. <br>
			 "dirty zero" is when you or the program assumes that the variable is not equal to zero - zero <br>
		</p>
		Very often, this error occurs in the interface of "machine operator". <br>
			 For example, after resetting the weight of packaging programs. <br>
	<pre>Dim a As Double
	'nulling the apparent magnitude
Private Sub Command1_Click()
    		Dim b As Double
    		Dim c As Double
  
    		b = Val(Replace(Text2.Text, ",", "."))
    		c = a - b
   		 Text3.Text = c
End Sub

Private Sub Form_Load()
		'Enter the number of 3FBF9ADD3746F67D 
     		a = 0.123456789012346 + 1E-16
    		Text1.Text = a
End Sub
</pre>	
<p>The result of the program in the above example<br><img src="./IEEE 754 - Standard binary floating point arithmetic_files/ieee754_23.gif" align="baseline"><br></p>		
<p>As a result, a variable that the operator considers zero - zero is not equal <br>
 Relative error of the result is infinity. <br>
 In the logical comparison operations that are not zero may divert program execution to another branch of the algorithm.

</p>


<h3>9.5 Error rate at the norma/denorma numbers. The number of killers.</h3>
	<p>
	These errors occur when working with numbers located on the border of the normalized / denormalized number representation.
 	They are associated with differences in the representation of numbers in IEEE754 format and transfer the difference formulas in IEEE754 format real numbers.
 	That is, the device (or software) should use different algorithms depending on the position of a real number on a number line format.
 	In addition, it leads to a complication of devices and algorithms, there are still uncertainties of the transition zone.
 	The uncertainty of the transition zone is that the standard does not define a specific value of the transition boundary.
	In essence, the transition boundary is between two real numbers:<br>
	The last denormalized number 000FFFFFFFFFFFFF:<br>
	Accurate decimal value of this number:<br>
	 +2,2250738585072008890245868760858598876504231122409594654935248025624400092282356951787758888037591552642309780950<br>
		4343120858773871583572918219930202943792242235598198275012420417889695713117910822610439719796040004548973919380791<br>
		9893608152561311337614984204327175103362739154978273159414382813627511383860409424946494228631669542910508020181592<br>
		6642134996606517803095075913058719846423906068637102005108723282784678843631944515866135041223479014792369585208321<br>
		5976210663754016137365830441936037147783553066828345356340050740730401356029680463759185831631242245215992625464943<br>
		0083685186171942241764645513713542013221703137049658321015465406803539741790602258950302350193751977303094576317321<br>
		0852507299305089761582519159720757232455434770912461317493580281734466552734375e-308<br><br>
	and the first normalized number 0010000000000000:<br>
	Accurate decimal value of this number:<br>
		+2,2250738585072013830902327173324040642192159804623318305533274168872044348139181958542831590125110205640673397310<br>
		3581100515243416155346010885601238537771882113077799353200233047961014744258363607192156504694250373420837525080665<br>
		0616658158948720491179968591639648500635908770118304874799780887753749949451580451605050915399856582470818645113537<br>
		9358049921159810857660519924333521143523901487956996095912888916029926415110634663133936634775865130293717620473256<br>
		3178148566435087212282863764204484681140761391147706280168985324411002416144742161856716615054015428508471675290190<br>
		3161322778896729707373123334086988983175067838846926092773977972858659654941091369095406136467568702398678315290680<br>
		984617210924625396728515625e-308<br>
	
	Since the boundary is a real number, its precision can be set to infinity and digital device or program
 	may not have the bit for a decision to include some range of the number.
	</p>

	For example, a bug<a target="_parent" href="http://bugs.php.net/53632"> №53632 </a>  for PHP, which caused panic in early 2011 
	<dl>
		<dt>&lt; html&gt;
		</dt><dd>&lt;body&gt;
		</dd><dd>&lt;?php $d = 2.2250738585072011e-308; ?&gt;
		</dd><dd>end
		</dd><dd>&lt;/boby&gt;
		</dd><dt>&lt;/html&gt;<br>
	</dt></dl>
	Enter a number 2.2250738585072011e-308 caused a hang of the process with nearly 100% load CPU.<br>
	Other numbers from this range of problems not caused (2.2250738585072009e-308, 2.2250738585072010e-308, 2.2250738585072012e-308)<br>
	Report a bug received 30.12.2010, 10.01.2011 fixed by the developer.<br>
	Since PHP is a preprocessor is used by most servers, then any user network within 10 days, was able to "close" any host.<br>
	How to write the developers that the bug only works in 32-bit systems, but if you increase the accuracy of the boundary, then I think that the 64-bit systems, too, hang (not verified!).<br>
	The reason for the panic is clear: any user, at a certain level of diligence and knowledge, had the opportunity to "cut down" most of the information resources of the planet within ten days.<br>
	I would not like - would result in more examples of such numbers and such errors.  <br>

<h3>§10 The final part</h3>
		<p>From the above it is clear that the view that the floating-point result is not beyond the relative error in reporting the greatest number is false.
 			Errors listed in Item 9 are added together. Such errors as dirty and dangerous zero reduction can make calculation errors unacceptable.
 			Particular attention in the programming of computer calculations the programmer should be paid to the results close to zero.
		</p>
		<p>
		Some experts believe that the format of numbers represents a threat to humanity. <br>
 			You can read about it in the article <a target="_parent" href="http://www.yur.ru/science/computer/IEEE754.htm"> IEEE754-tick threatens mankind </a> <br>
			 Although many of the facts in this article over-dramatized, and possibly misinterpreted, but the problem is computing correctly reflected philosophically.
	            </p>
		
		<p> I'm not a dramatization of the calculations on the standard IEEE754. Standard operating since 1985 and fully entered into the standard IEEE754-2008, which broadened the accuracy of calculations.
 			However, the problem of reliability computing today is very urgent, and the standard IEEE754-2008 and ISO recommendations have not solved this problem.
		 I think in this area needed an innovative idea that developers Standard IEEE754-2008 unfortunately do not possess.
		</p>
		<p>Innovative ideas usually come from. <br>
 			The main innovative ideas in our world were made by amateurs (like-minded people not for money). <br>
		 A striking example of this situation was the invention of the phone. <br>
			
			When a school teacher Alexander Graham Bell (Alexander Graham Bell) came up with a patent for an invention of the telephone to the president of telecommunications company Western Union Company,
 			which is owned by the transatlantic cable connection with an offer to buy his patent for the invention of the telephone, he was not expelled - no.
 			The president of that company offered to consider this question the advice of experts in the field of telegraphy, consisting of specialists and scholars in the field of telecommunications.
 			Experts gave their opinion that this invention is useless in the field of telecommunications and it is futile. <br>
 			Some experts have even written a report that it tsirkachestvo and charlatanism! <br>

			&nbsp; &nbsp; Alexander Graham Bell, along with his father in law, decided independently to promote his invention.
			 After about 10 years, the telecommunications giant Western Union Co., was virtually eliminated phone business from the sphere of telecommunication technologies.
			 Today you can see in many Russian cities windows that says Western Union, this company which is engaged in transferring money around the world, and once she was the international telecommunications giant. <br>
			 We can conclude: <strong> opinions of experts in innovative technologies are useless! </strong> <br>
			 If you think that since the invention of the telephone (1877) in people's minds that something has changed, you're wrong.
		</p>
		

		<p>If scientists (who are inventing new) and professionals (who know how to use the well-known) can not solve the problem, you need innovation. <br> <br>
			 Links to new ideas in the field of representation of real numbers in hardware: <br>
			 1. <a target="_parent" href="http://www.yur.ru/science/computer/appro/monografia.htm"> Approksimetika </a> <br>
			 2. ....?&lt; br&gt;
			 If you know of other innovative ideas in the field of representations of real numbers, then we will be happy to get links to these sources.

		</p>
		<p>I would suggest to represent real numbers as fixed-point.
			 To view the full range of numbers Double enough to have a variable consisting of 1075 bits integer part and 1075 bits of fractional part, ie about 270 bytes per variable.
			 In this case, all numbers will be presented with the same absolute accuracy.
			 You can work with numbers in the entire range the real axis, that is, it becomes possible to summarize large numbers of small numbers.
			 Step numbers on the real axis is uniform, that is the real axis is linear.
 			The data type will be only one, ie do not need the whole, real and other types.
			Here the problem is the realization of registers of microprocessors dimension of 270 bytes, but it's not a problem for modern technology. <br> <br>
			 To write p.9 I had to create a program that represents a number as a variable to a fixed point, long 1075.1075 bytes.
 			Where the number can be represented as a string of characters ASCII, ie one symbol equals one digits.
 			Just had to write all the arithmetic operations with strings ASCII.
 			This program is similar to a paper calculation. Since mathematical ability microprocessor in it are not used, she said slowly. <!--?-->
			 Why I did it? <br>
			I could not find a program that could accurately represent the number of IEEE754 format, in decimal form. <br>
			 I also did not find the program (although they certainly have what no doubt) where you can enter in box 1075 of significant decimal digits.<br> <br>
			 Here for example just the decimal value of the number of double 7FEFFFFFFFFFFFFF: <br>
			+17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955
			863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624
			549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316
			8738177180919299881250404026184124858368,0
		</p>
		<p>You can use the<a target="info01" href="http://www.softelectro.ru/pr_ieee754.html" title="IEEE754 format converter numbers"> IEEE754 v.1.0 </a>&nbsp;<br> to study and evaluate the errors when working with real numbers given in the format of IEEE754.
							
		</p>
		<p>References:<br>
		1.<font style="font-style : italic; font-size : 8pt "> IEEE Standard for Binary Floating-Point Arithmetic.  Copyright 1985 by  The Institute of Electrical and Electronics Engineers, Inc 345 East 47th Street, New York, NY 10017, USA</font>
		</p>
		<p>Acknowledgments:<br> 
		Sitkarevu Grigory(sitkarev@komitex.ru, sinclair80@gmail.com). For assistance in creating an article.

		</p>
		<p>Archive of reviews with comments &nbsp;  <a href="http://www.softelectro.ru/ieee754.txt"> View </a>&nbsp;&nbsp; <font style="font-size : 10pt ; font-style : italic; color :  black ">(Send us feedback on the e-mail:</font><a href="mailto:\\info@softelectro.ru"> info@softelectro.ru</a>)</p>	
		
		
		
		
		<hr>
		<a target="_parent" href="http://www.softelectro.ru/teoriy_en.html">Back </a>&nbsp;
		<a target="_parent" href="http://www.softelectro.ru/index_en.html"> Home  </a>&nbsp;
	
</body></html>