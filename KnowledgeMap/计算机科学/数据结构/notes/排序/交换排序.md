# 交换排序
2022.10.21

[TOC]

## 冒泡排序

![image-20220919195324632](resources/冒泡排序.png)

```C
void BubbleSort(ElemType A[], int n){
  bool flag;
  for(int i=0;i<n-1;i++){// 每一趟排序
    flag=false;
    for(int j=n-1;j>i;j--)
      if(A[j-1]>A[j]){
        swap(A[j-1],A[j]);
        flag = true;
      }
    if(flag==false) return; // 本躺遍历后没有发生交换，表已有序
  }
}
```

空间复杂度：O(1)

时间复杂度：平均O(n^2)，最坏O(n^2)

## 快速排序

> [快速排序可视化展示](https://www.bilibili.com/video/BV1Xv411w7PH)

```C
#include "stdio.h"

int Partition(SqList &L, int low, int high){
    // 将第一个元素设为轴
    DataType mid_e=GetItemRe(L,low);
    // 寻找轴
    while(low<high){
        printf("[%d - %d : %d] ",low,high, ele_get_weight(mid_e));
        ListPrint(L);
        while(low<high&& !ele_small(GetItemRe(L,high),mid_e))high--;
        ListSet(L,low,GetItemRe(L,high));
        printf("[%d - %d : %d] ",low,high, ele_get_weight(mid_e));
        ListPrint(L);
        while(low<high&& !ele_big(GetItemRe(L,low),mid_e))low++;
        ListSet(L,high,GetItemRe(L,low));
    }
    ListSet(L,low,mid_e);
    printf("----------->");ListPrint(L);
    return low;
}

void quick_sort(SqList &L, int low=1, int high=-1){
    if(high==-1) high=ListLength(L);
    if(low<high){
        int mid = Partition(L,low,high);
        quick_sort(L,low,mid-1);
        quick_sort(L,mid+1,high);
    }
}

void init_test_quick_sort(SqList &L, int num[],int  n){
    for(int i=0;i<n;i++)
        ListInsertIndex(L,i+1,ele_build(num[i]));
}

void test_quick_sort(){
    printf("交换排序 - 快速排序\n");

    SqList L;
    ListInit(L);
    int num[] = {5,3,1,7,2,4,6,8};
    init_test_quick_sort(L,num,8);
    quick_sort(L);
}

运行结果：
交换排序 - 快速排序
[1 - 8 : 5]  5  3  1  7  2  4  6  8 
[1 - 6 : 5]  4  3  1  7  2  4  6  8 
[4 - 6 : 5]  4  3  1  7  2  7  6  8 
[4 - 5 : 5]  4  3  1  2  2  7  6  8 
-----------> 4  3  1  2  5  7  6  8 
[1 - 4 : 4]  4  3  1  2  5  7  6  8 
[1 - 4 : 4]  2  3  1  2  5  7  6  8 
-----------> 2  3  1  4  5  7  6  8 
[1 - 3 : 2]  2  3  1  4  5  7  6  8 
[1 - 3 : 2]  1  3  1  4  5  7  6  8 
[2 - 3 : 2]  1  3  3  4  5  7  6  8 
[2 - 2 : 2]  1  3  3  4  5  7  6  8 
-----------> 1  2  3  4  5  7  6  8 
[6 - 8 : 7]  1  2  3  4  5  7  6  8 
[6 - 7 : 7]  1  2  3  4  5  6  6  8 
-----------> 1  2  3  4  5  6  7  8 
```

时间复杂度：O($nlog_2n$)，是所有算法中平均性能最优的排序算法
