# 队列
2022.09.06

[TOC]

## 队列的基本概念

操作受限的线性表、先进先出FIFO、队头（删除）、队尾（添加）、空队列

## 队列的顺序存储

```C++
// 队列的顺序实现 - 两种方案
/**
 * 定义
 * 初始化
 * 判空
 * 增
 * 删
 * 查
 */

#include<stdio.h>

// 定义
#define MaxSize 10
typedef struct
{
	int data[MaxSize];
	int front,rear;
}SqQueue1;// 会浪费一个空间

typedef struct
{
	int data[MaxSize];
	int front,rear;
	int size;
}SqQueue2; // 不会浪费空间

typedef struct
{
	int data[MaxSize];
	int front,rear;
	int tag; 
	// 当最近一次是删除时, tag==0, - 只有删除才能导致队空,
	// 当最近一次是添加时, tag==1; - 只有插入再能导致队满.
	// 队满条件: Q.rear==Q.front && Q.tag=1;
	// 队空条件: Q.rear==Q.front && Q.tag=0;
}SqQueue3; // 不会浪费空间

// 初始化
bool InitSqQueue1(SqQueue1 &Q){
	Q.front = 0;
	Q.rear = 0;
	return true;
}
// 队尾指针可能指向下一个要插入的元素, 也可以能指向最后一个内容, 考试时要注意

bool InitSqQueue2(SqQueue2 &Q){
	Q.front = 0;
	Q.rear = 0;
	Q.size = 0;
	return true;
}

// 判空
bool EmptySqQueue1(SqQueue1 Q){
	return Q.front == Q.rear;
}

bool EmptySqQueue2(SqQueue2 Q){
	return Q.size == 0;
}

// 插入
bool EnQueue1(SqQueue1 &Q, int x){
	// 队满
	if((Q.rear+1)%MaxSize == Q.front) return false;
	// 插入
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear+1)%MaxSize;//取余运算
	return true;
}

bool EnQueue2(SqQueue2 &Q, int x){
	// 队满
	if(Q.size==MaxSize) return false;
	// 插入
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear+1)%MaxSize;//取余运算
	Q.size++;
	return true;
}

// 出队
bool DeQueue1(SqQueue1 &Q, int &x){
	// 队空
	if(Q.rear == Q.front) return false;
	// 删除
	x = Q.data[Q.front];
	Q.front = (Q.front+1)%MaxSize;
	return true;
}

bool DeQueue2(SqQueue2 &Q, int &x){
	// 队空
	if(Q.size == 0) return false;
	// 删除
	x = Q.data[Q.front];
	Q.front = (Q.front+1)%MaxSize;
	Q.size--;
	return true;
}

// 获取队头
bool GetHead1(SqQueue1 &Q, int &x){
	// 队空
	if(Q.rear == Q.front) return false;
	// 删除
	x = Q.data[Q.front];
	return true;
}

bool GetHead2(SqQueue2 &Q, int &x){
	// 队空
	if(Q.rear == Q.front) return false;
	// 删除
	x = Q.data[Q.front];
	return true;
}

int main(){
	SqQueue1 Q;
	InitSqQueue1(Q);
	EnQueue1(Q,1);
	EnQueue1(Q,2);
	EnQueue1(Q,3);

	return 0;
}
```



## 队列的链式存储

```C++
// 队列的链式实现
/**
 * 定义
 * 初始化
 * 判空
 * 增
 * 删
 * 查
 */

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

// 定义
typedef struct LNode
{
	int data;
	struct LNode *next;
}LNode;

typedef struct
{
	LNode *front, *rear;	
}LinkQueue;

// 初始化 - 带头节点
void InitQueue1(LinkQueue &Q){
	Q.rear = (LNode*)malloc(sizeof(LNode));
	if(Q.rear == NULL) return;
	Q.front = Q.rear;
	Q.front->next = NULL;
}

// 初始化 - 不带头节点
void InitQueue2(LinkQueue &Q){
	Q.rear = NULL;
	Q.front = Q.rear;
}

// 判空 - 带头节点
bool EmptyLinkQueue1(LinkQueue Q){
	return Q.rear == Q.front;
}

// 判空 - 不带头节点
bool EmptyLinkQueue2(LinkQueue Q){
	return Q.front==NULL;
}

// 进栈 - 带头节点
void EnQueue1(LinkQueue &Q, int x){
	// 创建新节点
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->next = NULL;
	s->data = x;
	// 尾插
	Q.rear->next = s;
	// 修改尾指针
	Q.rear = s;
}

// 进栈 - 不带头节点
void EnQueue2(LinkQueue &Q, int x){
	// 创建新节点
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->next = NULL;
	s->data = x;
	// 尾插
	if(Q.rear==NULL){
		Q.rear = s;
		Q.front = s;
	}else{
		Q.rear->next = s;
		Q.rear = s;
	}
}

// 出栈 - 带头节点
bool DeQueue1(LinkQueue &Q,int &x){
	// 空队
	if(Q.rear==Q.front)return false;
	// 获取第一个节点
	LNode *s = Q.front->next;
	// 获取数据并返回
	x = s->data;
	// 改变front
	Q.front->next = s->next;
	// 改变rear - 最后一个节点
	if(s->next==NULL)
		Q.rear = Q.front;
	// 释放第一个节点
	free(s);
	return true;
}

// 出栈 - 不带头节点
bool DeQueue2(LinkQueue &Q,int &x){
	// 空队
	if(Q.front==NULL)
		return false;
	// 获取节点s
	LNode *s = Q.front;
	// 保存数据
	x = Q.front->data;
	// 连接队列
	if(Q.rear==Q.front)
		Q.rear=NULL;
	Q.front = s->next;
	// 删除s
	free(s);
	return true;
}

// 取队列元素 - 带头节点
bool GetFront1(LinkQueue Q,int &x){
	if(Q.rear==Q.front)return false;
	x = Q.front->next->data;
	return true;
}

// 取队列元素 - 不带头节点
bool GetFront2(LinkQueue Q,int &x){
	if(Q.rear==NULL)return false;
	x = Q.front->data;
	return true;
}

int main(){
	int x=0;
	printf("带头节点队列测试\n");
	LinkQueue Q1;
	InitQueue1(Q1);
	printf("是否为空:%d\n",EmptyLinkQueue1(Q1));
	printf("插入 1 ");EnQueue1(Q1,1);
	printf("插入 2 ");EnQueue1(Q1,2);
	printf("插入 3 ");EnQueue1(Q1,3);
	printf("插入 4 ");EnQueue1(Q1,4);
	printf("\n是否为空:%d\n",EmptyLinkQueue1(Q1));
	DeQueue1(Q1,x);printf("出栈 %d ",x);
	DeQueue1(Q1,x);printf("出栈 %d ",x);
	DeQueue1(Q1,x);printf("出栈 %d ",x);
	DeQueue1(Q1,x);printf("出栈 %d ",x);
	printf("\n是否为空:%d\n",EmptyLinkQueue1(Q1));


	printf("\n不带头节点队列测试\n");
	LinkQueue Q2;
	InitQueue2(Q2);
	printf("是否为空:%d\n",EmptyLinkQueue2(Q2));
	printf("插入 1 ");EnQueue2(Q2,1);
	printf("插入 2 ");EnQueue2(Q2,2);
	DeQueue2(Q2,x);printf("出栈 %d ",x);
	printf("插入 3 ");EnQueue2(Q2,3);
	printf("插入 4 ");EnQueue2(Q2,4);
	printf("\n是否为空:%d\n",EmptyLinkQueue2(Q2));
	DeQueue2(Q2,x);printf("出栈 %d ",x);
	DeQueue2(Q2,x);printf("出栈 %d ",x);
	DeQueue2(Q2,x);printf("出栈 %d ",x);
	DeQueue2(Q2,x);printf("出栈 %d ",x);
	printf("\n是否为空:%d\n",EmptyLinkQueue1(Q2));
	return 0;
}
```

## 双端队列

* 双端队列：指的是两端都可以自由进出的队列
* 受限的双端队列

## 习题

1. 栈和队列的主要区别在于（）
   A. 它们的逻辑结构不一样
   C.所包含的元素不一样
   B. 它们的存储结构不一样
   D. 插入、删除操作的限定不一样

   【答案】：D

2. 队列的“先进先出”特性是指（）
   I. 最后插入队列中的元素总是最后被删除
   II. 当同时进行插入、删除操作时，总是插入操作优先
   III. 每当有删除操作时，总要先做一次插入操作
   IV.每次从队列中删除的总是最早插入的元素
   A. I
   B.I和I
   C.I和I
   D. IV

   【答案】：

3. 允许对队列进行的操作有（）。
   A.对队列中的元素排序
   B. 取出最近进队的元素
   C.在队列元素之间插入元素
   D.删除队头元素

4. 一个队列的入队顺序是1，2,3，4，则出队的输出顺序是(）。
   A. 4,3,2,1
   B. 1,2,3,4
   C. 1,4,3,2
   D. 3.2.4,1

5. 循环队列存储在数组A[O..n]中，入队时的操作为（）。
   A. rearsrear+l
   B.
   rear-(rear+1) mod 1n-1)
   C rear=(rear+l) mod
   n
   D.
   rear=(rear+1) mod (n+1)

6. 已知销环队列的存储空问为教組 A211，什天oat 指白队头元素的前-下个位量东rear指
   向队尾元素，假设当前front 和rear 的值分别为8和了，则该队列的长度为（）。
   A.5
   B. 6
   C. 15计

7. 若用数组A[0..5]来实现铺环队列，且当前rear和front的值分别为 1和5，当从队
   列中州除一个元素，再加入两个元素后，rear 和front 的值分别为（ ）。