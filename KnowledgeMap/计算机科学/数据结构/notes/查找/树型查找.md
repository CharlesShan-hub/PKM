# 树型查找
2022.09.18

[TOC]

## 二叉排序树(BST)

1. 核心思想

   1. 左<根<右
   2. 删除一个结点：如果某一边子树为空，就把另一边子树接上。如果两边子树都不是空，就找到右边的最左下或左边的最右下，放到删除的结点的位置。

2. 核心代码

   ```C
   BSTNode *BSTSearch(BSTree &_T,Element e,BSTree &father){
       BSTNode *T = _T;
       father=NULL;
   	while(T!=NULL && ele_get_weight(T->data)!= ele_get_weight(e)){
           visit(T);
           if(ele_get_weight(e) < ele_get_weight(T->data))
           {father=T;T=T->lchild;}
           else
           {father=T;T=T->rchild;}
       }
   	return T;
   }
   
   bool BSTInsert(BSTree &p,Element e){
       BSTNode *q = p;
   	if(q==NULL){
           InitTree(p);
           SetTreeData(p,e);
           return true;
       }
       while(1){
           visit(q);
           if(ele_get_weight(e)< ele_get_weight(q->data))
               if(q->lchild == NULL)
                   return InsertLeftTree(q,e);
               else
                   q = q->lchild;
           else if(ele_get_weight(e)> ele_get_weight(q->data))
               if(q->rchild == NULL)
                   return InsertRightTree(q,e);
               else
                   q = q->rchild;
           else
               return false;
       }
   }
   
   bool BSTDelete1(BSTree &p,BSTree &father){
       if(father->rchild==p)
           father->rchild=NULL;
       else
           father->lchild=NULL;
       free(p);
       return true;
   }
   
   bool BSTDelete2(BSTree &p,BSTree &father){
       BSTNode *q = NULL;
       if(p->rchild==NULL)
           q=p->lchild;
       else
           q=p->rchild;
       if(father->rchild==p)
           father->rchild=q;
       else
           father->lchild=q;
       free(p);
       return true;
   }
   
   bool BSTDelete(BSTree &T, Element e){
       BSTNode *father;
       BSTNode *p = BSTSearch(T,e,father);
       if(p==NULL) return false;
   
       // 如果是叶子结点——直接删除
       if(p->rchild==NULL&&p->lchild==NULL){
           return BSTDelete1(p,father);
       }
   
       // 如果左子树或右子树为空
       if(p->rchild==NULL||p->lchild==NULL){
           return BSTDelete2(p,father);
       }
   
       // 左子树右子树都非空 - 找到左边的最右下或右边的最左下
       BSTNode *q = p->rchild;
       if(q->rchild==NULL && q->lchild==NULL){
           ele_copy(p->data,q->data);
           return BSTDelete1(q,p);
       }
       BSTNode *qf = p;
       while(1){
           if(q->lchild==NULL){
               ele_copy(p->data,q->data);
               break;
           }else{
               qf=q;
               q=q->lchild;
           }
       }
       if(q->rchild==NULL)
           return BSTDelete1(q,qf);
       else{
           ele_copy(q->data,q->rchild->data);
           return BSTDelete2(q,qf);
       }
   }
   ```

3. 运行结果展示

   ```
   ============================
   二叉排序树
   
   二叉排序树的构建
   Insert 19 :
   先序遍历 : 19 
   
   Insert 13 :19 
   先序遍历 : 19 13 
   
   Insert 50 :19 
   先序遍历 : 19 13 50 
   
   Insert 11 :19 13 
   先序遍历 : 19 13 11 50 
   
   Insert 26 :19 50 
   先序遍历 : 19 13 11 50 26 
   
   Insert 66 :19 50 
   先序遍历 : 19 13 11 50 26 66 
   
   Insert 21 :19 50 26 
   先序遍历 : 19 13 11 50 26 21 66 
   
   Insert 30 :19 50 26 
   先序遍历 : 19 13 11 50 26 21 30 66 
   
   Insert 60 :19 50 66 
   先序遍历 : 19 13 11 50 26 21 30 66 60 
   
   Insert 70 :19 50 66 
   先序遍历 : 19 13 11 50 26 21 30 66 60 70 
   
   
   得到二叉排序树:
         A-19
        /    \
       B-13  C-50
      /     /    \
     D-11  E-26   F-66
          / \     /  \
      G-21 H-30  I-60 J-70
   
   寻找值为n的结点
   60是否存在: 19 50 66 
   71是否存在: 19 50 66 70 
   26是否存在: 19 50 
   
   插入结点
   插入71:19 50 66 70 
   插入31:19 50 26 30 
         A-19
        /    \
       B-13  C-50
      /     /    \
     D-11  E-26   F-66
          / \     /  \
      G-21 H-30  I-60 J-70
              \        \
              K-31     L-71
   
   删除结点
   删除叶子结点 31 - 直接删除 - 19 50 26 30 
   先序遍历 : 19 13 11 50 26 21 30 66 60 70 71 
   中序遍历 : 11 13 19 21 26 30 50 60 66 70 71 
   
   删除结点左或右子树为空 13 - 用子树替代自己 - 19 
   先序遍历 : 19 11 50 26 21 30 66 60 70 71 
   中序遍历 : 11 19 21 26 30 50 60 66 70 71 
   
   删除结点左右子树非空 66 - 找右边最左下 - 19 50 
   先序遍历 : 19 11 50 26 21 30 70 60 71 
   中序遍历 : 11 19 21 26 30 50 60 70 71 
   
   删除结点左右子树非空 26 - 用子树替代自己 - 19 50 
   先序遍历 : 19 11 50 30 21 70 60 71 
   中序遍历 : 11 19 21 30 50 60 70 71 
   ```

## 平衡二叉树(AVL)



## 红黑树

